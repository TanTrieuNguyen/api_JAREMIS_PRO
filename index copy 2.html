<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>JAREMIS - AI Chat</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
    <style>
        :root {
            --sidebar-width: 260px;
            --bg-color: #0d1117;
            --sidebar-bg: #161b22;
            --chat-bg: #010409;
            --input-bg: #161b22;
            --bot-bubble-bg: #161b22;
            --user-bubble-bg: #003666;
            --text-color: #c9d1d9;
            --text-secondary-color: #8b949e;
            --border-color: #30363d;
            --accent-color: #2f81f7;
            --error-color: #f85149;
            --success-color: #238636;
            --who-bg: #212013;
            --mic-red: #ff4d4d;

            --auth-offset-top: 12px;
            --auth-offset-height: 48px; /* chi·ªÅu cao ∆∞·ªõc l∆∞·ª£ng v√πng auth (ƒë·ªÉ ch·ª´a kho·∫£ng tr·ªëng) */
            --mobile-header-height: 56px; /* chi·ªÅu cao header mobile (n·∫øu hi·ªán) */
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Hide mobile-only toggles on desktop */
        .mobile-header { display: none; }
        #history-drawer-toggle { display: none; }

        .chat-container { display: flex; width: 100%; height: 100%; }

        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            min-width: 200px;
            max-width: 500px;
            background-color: var(--sidebar-bg);
            display: flex;
            flex-direction: column;
            padding: 16px;
            transition: width 0.1s ease-out;
            flex-shrink: 0;
        }
        .resizer { width: 5px; cursor: col-resize; background-color: transparent; flex-shrink: 0; position: relative; z-index: 10; }
        .resizer:hover { background-color: var(--accent-color); }

        .sidebar-header {
          display:flex;
          flex-direction:column;
          align-items:stretch;
          gap:8px;
          margin-bottom:12px;
        }

        .new-chat-btn {
            display:flex; align-items:center; gap:8px; width:100%; padding:10px; background:transparent; color:var(--text-color);
            border:1px solid var(--border-color); border-radius:6px; font-size:14px; cursor:pointer;
        }
        .new-chat-btn:hover { background-color:#2c313a; }

        .history { flex-grow:1; overflow-y:auto; margin-top:10px; }
        .history h3 { font-size:12px; color:var(--text-secondary-color); margin-bottom:8px; text-transform:uppercase; display:flex; justify-content:space-between; align-items:center; }
        .history ul { list-style:none; padding:0; display:flex; flex-direction:column; gap:6px; }
        .history li { padding:8px; border-radius:6px; cursor:pointer; color:var(--text-color); background:transparent; border:1px solid transparent; font-size:13px; }
        .history li:hover { background:#111720; border-color:var(--border-color); }
        .sidebar-footer { font-size:12px; color:var(--text-secondary-color); text-align:center; margin-top:10px; }

        /* Chat area */
        .chat-area {
            position: relative; /* ƒê·∫£m b·∫£o l·ªõp n·ªÅn ph·ªß ƒë√∫ng */
            flex-grow:1; display:flex; flex-direction:column; background-color:var(--chat-bg); border-left:1px solid var(--border-color); /* position:relative; */
        }
        .chat-messages {
          flex-grow:1;
          padding:24px;
          overflow-y:auto;
          display:flex;
          flex-direction:column;
          gap:20px;
          background: transparent;          /* ƒë·∫£m b·∫£o kh√¥ng che n·ªÅn */
          scrollbar-color: var(--accent-color) transparent; /* Firefox */
          scrollbar-width: thin;
        }

        /* Scrollbar WebKit (Chrome / Edge) */
        .chat-messages::-webkit-scrollbar {
          width: 10px;
        }
        .chat-messages::-webkit-scrollbar-track {
          background: transparent;          /* trong su·ªët ƒë·ªÉ l·ªô n·ªÅn & canvas tuy·∫øt */
        }
        .chat-messages::-webkit-scrollbar-thumb {
          background: linear-gradient(180deg, rgba(47,129,247,0.55), rgba(47,129,247,0.25));
          border-radius: 20px;
          border: 2px solid rgba(0,0,0,0);  /* t·∫°o kho·∫£ng c√°ch th·ªã gi√°c */
          min-height: 40px;
          transition: background .25s;
        }
        .chat-messages::-webkit-scrollbar-thumb:hover {
          background: linear-gradient(180deg, rgba(47,129,247,0.85), rgba(47,129,247,0.45));
        }
        .chat-messages::-webkit-scrollbar-corner {
          background: transparent;
        }
        /* (Tu·ª≥ ch·ªçn) ·∫®n h·∫≥n khi kh√¥ng hover:
        .chat-messages::-webkit-scrollbar { width: 0; }
        */

        .chat-bubble { max-width:80%; padding:16px; border-radius:12px; line-height:1.6; word-wrap:break-word; }
        .bot-bubble { background-color:var(--bot-bubble-bg); align-self:flex-start; border:1px solid var(--border-color); }
        .user-bubble { background-color:var(--user-bubble-bg); align-self:flex-end; color:#fff; }

        .user-bubble-content p { margin-bottom:12px; }
        .user-images-preview { display:flex; gap:10px; flex-wrap:wrap; }
        .user-images-preview img { width:80px; height:80px; object-fit:cover; border-radius:8px; border:1px solid var(--border-color); }

        .chat-input-area { padding:16px 24px; border-top:1px solid var(--border-color); display:flex; flex-direction:column; gap:8px; }
        .input-wrapper { position:relative; display:flex; align-items:center; background-color:var(--input-bg); border:1px solid var(--border-color); border-radius:8px; padding:8px; gap:8px; }

        #chat-input { flex-grow:1; background:transparent; border:none; color:var(--text-color); font-size:16px; padding:8px; resize:none; max-height:200px; overflow-y:auto; }
        #chat-input:focus { outline:none; }

        .input-actions { display:flex; align-items:center; gap:8px; }
        .action-btn {
            background:none; border:none; color:var(--text-secondary-color); font-size:20px; cursor:pointer; width:40px; height:40px; border-radius:6px;
            display:flex; align-items:center; justify-content:center;
        }
        .action-btn:hover { background-color:#2c313a; color:var(--text-color); }
        #send-btn { background-color:var(--accent-color); color:white; border-radius:6px; width:44px; height:40px; display:flex; align-items:center; justify-content:center; }
        #send-btn:disabled { background-color:#30363d; cursor:not-allowed; }

        #image-preview-container { display:flex; gap:10px; margin-top:10px; padding:0 8px; }
        .preview-item { position:relative; }
        .preview-item img { width:60px; height:60px; object-fit:cover; border-radius:6px; }
        .remove-btn { position:absolute; top:-5px; right:-5px; background:var(--error-color); color:white; border:none; width:20px; height:20px; border-radius:50%; cursor:pointer; font-size:12px; display:flex; align-items:center; justify-content:center; }

        /* Analysis steps */
        .analysis-steps { display:flex; flex-direction:column; gap:12px; }
        .step-item { display:flex; align-items:center; gap:12px; font-size:14px; transition:color 0.3s ease; }
        .step-item .icon { width:20px; text-align:center; }
        .step-item.pending { color:var(--text-secondary-color); }
        .step-item.active { color:var(--text-color); font-weight:600; }
        .step-item.completed { color:var(--success-color); }
        .fa-spinner { animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform:rotate(0deg); } 100% { transform:rotate(360deg); } }

        /* Result */
        .error-message { color:var(--error-color); }
        .confidence-meter { background:#2c313a; border-radius:20px; height:24px; margin:16px 0; overflow:hidden; position:relative; }
        .confidence-bar { background:var(--success-color); height:100%; display:flex; align-items:center; padding-left:12px; color:white; font-weight:bold; font-size:12px; transition: width 0.5s ease; }

        .disease-list { margin:20px 0; display:flex; flex-direction:column; gap:15px; }
        .disease-item { border-left:3px solid var(--accent-color); padding-left:15px; }
        .probability-bar { height:8px; background:#30363d; border-radius:10px; overflow:hidden; margin-top:8px; }
        .probability-fill { height:100%; background:var(--accent-color); transition:width 0.5s ease; }

        .diagnosis-details h2, .diagnosis-details h3 { border-bottom:1px solid var(--border-color); padding-bottom:8px; margin:20px 0 10px 0; font-size:1.1em; }
        .references-section { margin-top:25px; padding:15px; background:rgba(47,129,247,0.1); border-radius:8px; }
        .reference-item { margin-top:10px; }
        .reference-item a { color:var(--accent-color); text-decoration:none; }
        .reference-item a:hover { text-decoration:underline; }
        .reference-source { font-size:0.8em; color:var(--text-secondary-color); margin-top:4px; }

        .warning { margin-top:20px; padding:12px; background:var(--who-bg); border-left:4px solid #f1e05a; color:#d4c873; font-size:14px; border-radius:4px; }
        .warning strong { color:#f1e05a; }

        /* Think button style */
        #think-btn { background:none; border:1px solid var(--border-color); border-radius:6px; padding:6px 8px; color:var(--text-secondary-color); cursor:pointer; width:auto; height:40px; display:flex; align-items:center; justify-content:center; }
        #think-btn.active { background: linear-gradient(90deg, rgba(47,129,247,0.12), rgba(47,129,247,0.06)); color:var(--text-color); border-color: rgba(47,129,247,0.6); }
        #model-status { font-size:12px; color:var(--text-secondary-color); margin-left:8px; align-self:center; }

        /* Mic button style */
        #mic-btn { background:none; border:1px solid var(--border-color); border-radius:6px; padding:6px 8px; color:var(--text-secondary-color); cursor:pointer; width:auto; height:40px; display:flex; align-items:center; justify-content:center; }
        #mic-btn.recording { background: rgba(255,77,77,0.12); color: var(--text-color); border-color: rgba(255,77,77,0.5); box-shadow: 0 0 8px rgba(255,77,77,0.12); }
        #mic-indicator {
            width:8px; height:8px; border-radius:50%; background:var(--mic-red); margin-left:6px; display:inline-block; opacity:0;
            box-shadow: 0 0 6px rgba(255,77,77,0.8);
            animation: pulse 1.2s infinite;
        }
        #mic-btn.recording #mic-indicator { opacity:1; }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.5); opacity: 0.5; }
            100% { transform: scale(1); opacity: 0.9; }
        }

        /* Auth UI (top-right) */
        .auth-controls {
            position: fixed !important;
            top: var(--auth-offset-top) !important;
            right: 18px !important;
            bottom: auto !important;
            display: flex;
            gap: 8px;
            align-items: center;
            z-index: 120; /* cao h∆°n header & bong b√≥ng */
            flex-direction: row !important;
        }
        @media (max-width:600px) {
            .auth-controls { right: 10px; }
        }

        /* Modal */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 60;
        }
        .modal {
            background: #0b1116;
            border: 1px solid var(--border-color);
            padding: 18px;
            border-radius: 10px;
            width: 360px;
            max-width: 92%;
            color: var(--text-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
        }
        .modal h3 { margin-bottom: 10px; font-size: 18px; }
        .tabs { display:flex; gap:8px; margin-bottom:12px; }
        .tab { padding:8px 12px; border-radius:6px; cursor:pointer; background:transparent; color:var(--text-secondary-color); border:1px solid transparent; }
        .tab.active { background: rgba(47,129,247,0.12); color:var(--text-color); border-color: rgba(47,129,247,0.2); }
        .form-row { margin-bottom:10px; display:flex; flex-direction:column; gap:6px; }
        .form-row input { background: #071018; border: 1px solid var(--border-color); color: var(--text-color); padding:8px 10px; border-radius:6px; }
        .form-actions { display:flex; justify-content:space-between; align-items:center; gap:8px; margin-top:8px; }
        .btn-primary { background: var(--accent-color); color: #fff; padding:8px 12px; border-radius:6px; border:none; cursor:pointer; }
        .btn-ghost { background:transparent; color:var(--text-secondary-color); border:1px solid var(--border-color); padding:8px 10px; border-radius:6px; cursor:pointer; }

        .small-muted { font-size:12px; color:var(--text-secondary-color); margin-top:8px; }

        /* Base (desktop) ‚Äì gi·ªØ h√†ng ngang cho tool buttons */
        .tool-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .toggle-tools-btn {
            display: none; /* Ch·ªâ hi·ªán tr√™n mobile */
        }

        /* Auth buttons styling */
        .auth-controls .auth-btn {
            background: rgba(255,255,255,0.04);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 6px 10px;
            font-size: 13px;
            border-radius: 6px;
            cursor: pointer;
            line-height: 1.2;
            backdrop-filter: blur(4px);
            transition: background .18s, border-color .18s, color .18s;
        }
        .auth-controls .auth-btn:hover {
            background: rgba(47,129,247,0.16);
            border-color: var(--accent-color);
            color: #fff;
        }
        .auth-controls .auth-btn:active {
            background: rgba(47,129,247,0.28);
        }

        /* small responsive */
        @media (max-width: 900px) {
            .sidebar { display:none; }
            .resizer { display:none; }
            .auth-controls { right: 8px; top: 8px; }
        }

        /* Mobile-specific overrides */
        @media (max-width: 600px) {
            /* layout becomes column for small screens */
            .chat-container { flex-direction:column; }
            .mobile-header { display:flex; align-items:center; gap:10px; padding:8px 10px; border-bottom:1px solid var(--border-color); background:var(--chat-bg); position:sticky; top:0; z-index:70; }
            .mobile-header .title { color:var(--text-color); font-weight:600; font-size:16px; flex:1; text-align:center; }
            .hamburger { background:transparent; border:1px solid var(--border-color); color:var(--text-secondary-color); width:44px; height:44px; border-radius:8px; display:inline-flex; align-items:center; justify-content:center; }
            /* Sidebar becomes overlay (hidden by default) */
            .sidebar { display:flex; position:fixed; top:0; left:0; bottom:0; width:78%; max-width:360px; transform:translateX(-120%); transition: transform 0.22s ease; z-index:80; box-shadow:6px 0 30px rgba(0,0,0,0.6); }
            .sidebar.mobile-open { transform:translateX(0); }
            .sidebar-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:75; display:none; }
            .sidebar-backdrop.show { display:block; }
            /* hide resizer (not needed) */
            .resizer { display:none; }
            /* Chat area sizing */
            .chat-area { flex:1 1 auto; min-height: calc(100vh - 56px); }
            .chat-messages { padding: 12px; padding-bottom:160px; overflow-y:auto; }
            /* Fix input to bottom and respect safe-area */
            .chat-input-area { position:fixed; left:0; right:0; bottom:env(safe-area-inset-bottom, 0); padding:8px 10px; background:linear-gradient(180deg, rgba(1,4,9,0.98), rgba(1,4,9,1)); z-index:70; border-top:1px solid var(--border-color); }
            .input-wrapper { padding:6px; gap:6px; }
            #chat-input { font-size:15px; padding:8px; max-height:120px; }
            .input-actions .action-btn { width:40px; height:40px; font-size:16px; }
            #send-btn { width:44px; height:40px; border-radius:8px; }
            /* Adjust auth controls so they don't overlap mobile input */
            .auth-controls { position:fixed; right:10px; bottom:110px; top:auto; z-index:69; display:flex; flex-direction:column; gap:8px; }
            /* Slightly reduce bubble max-width for narrow screens */
            .chat-bubble { max-width:94%; }
        }

        /* Even smaller devices: compact spacing & font sizes */
        @media (max-width: 420px) {
            .mobile-header { padding:6px 8px; }
            .mobile-header .title { font-size:14px; }
            .new-chat-btn span { display:none; } /* icon only to save space */
            .sidebar { width:84%; max-width:300px; }
            .chat-messages { padding:10px; padding-bottom:150px; gap:12px; }
            .input-actions .action-btn { width:38px; height:38px; font-size:15px; }
            #chat-input { font-size:14px; }
        }

        @media (max-width: 360px) {
            .mobile-header .title { font-size:13px; }
            .hamburger { width:40px; height:40px; }
            .auth-controls { right:8px; bottom:120px; }
            .chat-input-area { padding:8px; }
            .chat-messages { padding-bottom:140px; }
        }

        /* Compact tools (mobile) */
        @media (max-width:600px) {
            .input-wrapper {
                position: relative;
            }
            .toggle-tools-btn {
                display:flex !important;
            }
            .tool-buttons {
                display:flex;
                align-items:center;
                gap:6px;
                transition:opacity .18s ease, transform .18s ease;
            }
            .tool-buttons.collapsed {
                opacity:0;
                pointer-events:none;
                transform:translateY(4px);
                position:absolute;
                left:8px;
                right:60px;
                bottom:100%;
                /* hidden */
            }
            .mobile-tools-active .tool-buttons {
                opacity:1;
                transform:translateY(0);
                position:absolute;
                left:8px;
                right:60px;
                bottom:100%;
                background:rgba(22,27,34,0.95);
                padding:6px 8px;
                border:1px solid var(--border-color);
                border-radius:10px;
                box-shadow:0 4px 18px rgba(0,0,0,0.55);
                z-index:90;
            }
            .tool-buttons .action-btn {
                width:38px;
                height:38px;
                font-size:16px;
            }
            .toggle-tools-btn {
                display:flex;
                background:none;
                border:1px solid var(--border-color);
                width:40px;
                height:40px;
                border-radius:8px;
                align-items:center;
                justify-content:center;
                color:var(--text-secondary-color);
                cursor:pointer;
            }
            .toggle-tools-btn.active {
                background:rgba(47,129,247,0.15);
                color:var(--text-color);
                border-color:var(--accent-color);
            }
            /* Khi b√†n ph√≠m m·ªü (class keyboard-open g·∫Øn v√†o body) -> √©p thu g·ªçn */
            body.keyboard-open .tool-buttons:not(.force-open) {
                opacity:0;
                pointer-events:none;
                transform:translateY(4px);
            }
        }

        /* N√∫t toggle l·ªãch s·ª≠ tr√™n mobile */
        #history-toggle-btn {
            display:none;
            background:transparent;
            border:1px solid var(--border-color);
            color:var(--text-secondary-color);
            padding:6px 10px;
            border-radius:8px;
            font-size:13px;
            cursor:pointer;
        }
        #history-toggle-btn.active {
            background:rgba(47,129,247,0.15);
            color:var(--text-color);
            border-color:var(--accent-color);
        }
        @media (max-width:600px) {
          #history-toggle-btn { display:inline-flex; align-items:center; gap:6px; }
        }

        /* Dual pane (landscape + ƒë·ªß r·ªông) */
        @media (max-width:900px) and (orientation:landscape) and (min-width:640px) {
          body.dual-pane .sidebar {
              position:relative;
              transform:translateX(0) !important;
              width:230px;
              box-shadow:none;
          }
          body.dual-pane .sidebar-backdrop { display:none !important; }
          body.dual-pane .chat-area { min-height:100vh; }
          body.dual-pane #mobile-header { padding-right:0; }
          body.dual-pane #history-toggle-btn { display:none; }
        }
        /* Hi·ªáu ·ª©ng vu·ªët (g·ª£i √Ω) ‚Äì ch·ªâ chi·ªÅu ngang */
        .sidebar {
           touch-action: pan-y;
        }

        @media (max-width:600px) {
          .history-drawer-toggle {
              position:fixed;
              top:50%;
              left:4px;
              transform:translateY(-50%);
              z-index:90;
              width:34px;
              height:52px;
              background:rgba(22,27,34,0.88);
              border:1px solid var(--border-color);
              border-left:none;
              border-radius:0 10px 10px 0;
              display:flex;
              align-items:center;
              justify-content:center;
              color:var(--text-secondary-color);
              cursor:pointer;
              backdrop-filter:blur(4px);
              transition:background .18s, color .18s;
          }
          .history-drawer-toggle:hover { background:rgba(47,129,247,0.15); color:var(--text-color); }
          .history-drawer-toggle.open { left: calc(78% - 18px); border-left:1px solid var(--border-color); border-radius:10px 0 0 10px; }
        }

        /* Ph√≥ng to n√∫t history ‚â° */
.history-top-toggle .history-icon,
.history-drawer-toggle .history-icon {
    font-size: 26px; /* tƒÉng g·∫•p ~2 l·∫ßn so v·ªõi font-awesome m·∫∑c ƒë·ªãnh 14‚Äì16px */
    line-height: 1;
    display:inline-block;
    transform: translateY(-1px);
    letter-spacing:2px;
    font-weight:600;
}
.history-top-toggle,
.history-drawer-toggle {
    width:46px !important;
    height:46px !important;
}

/* Compact white triple bars button */
.history-top-toggle,
.history-drawer-toggle {
    background: var(--chat-bg) !important; /* tr√πng n·ªÅn ch√≠nh */
    border: 1px solid var(--border-color);
    box-shadow: 0 0 0 0 transparent;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:0;
}
.history-top-toggle:hover,
.history-drawer-toggle:hover {
    border-color: var(--accent-color);
    background: var(--chat-bg);
}
.history-top-toggle .bars,
.history-drawer-toggle .bars {
    display:flex;
    flex-direction:column;
    gap:5px;
    width:26px;
    height:22px;
    align-items:flex-start;
    justify-content:center;
}
.history-top-toggle .bar,
.history-drawer-toggle .bar {
    display:block;
    height:2px;              /* thon h∆°n */
    width:22px;
    background:#fff;          /* m√†u tr·∫Øng */
    border-radius:2px;
    transition:width .25s ease, background .25s;
}
.history-top-toggle .bar:nth-child(2),
.history-drawer-toggle .bar:nth-child(2){
    width:18px;               /* gi·ªØa ng·∫Øn h∆°n nh·∫π */
}
.history-top-toggle .bar:nth-child(3),
.history-drawer-toggle .bar:nth-child(3){
    width:14px;               /* d∆∞·ªõi ng·∫Øn h∆°n n·ªØa */
}
.history-top-toggle.open .bar,
.history-drawer-toggle.open .bar {
    background: var(--accent-color);
    width:22px;               /* khi m·ªü ƒë·ªìng nh·∫•t chi·ªÅu d√†i */
}
.history-top-toggle.open .bar:nth-child(2){
    width:22px;
}
.history-top-toggle.open .bar:nth-child(3){
    width:22px;
}
/* ·∫®n style c≈© c·ªßa .history-icon n·∫øu c√≤n */
.history-icon { display:none !important; }

/* Override: lo·∫°i vi·ªÅn tr·∫Øng m·ªù n√∫t history */
.history-top-toggle,
.history-drawer-toggle {
    border: 1px solid var(--chat-bg) !important; /* tr√πng n·ªÅn -> coi nh∆∞ m·∫•t vi·ªÅn */
}

.history-top-toggle:hover,
.history-drawer-toggle:hover,
.history-top-toggle.open,
.history-drawer-toggle.open {
    border: 1px solid var(--border-color) !important; /* ch·ªâ hi·ªán vi·ªÅn khi hover / m·ªü */
}

/* (Tu·ª≥ ch·ªçn) n·∫øu mu·ªën b·ªè h·∫≥n vi·ªÅn lu√¥n:
.history-top-toggle,
.history-drawer-toggle { border:0 !important; }
.history-top-toggle:hover,
.history-drawer-toggle:hover { border:0 !important; }
*/
/* Th√™m ngay sau <body> */
.bg-animation {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 0; /* n·∫±m d∆∞·ªõi c√°c chat bubble */
}
.particle {
    position: absolute;
    width: 4px; height: 4px;
    background: #8b5cf6;
    border-radius: 50%;
    animation: float 20s infinite linear;
    box-shadow: 0 0 10px #8b5cf6;
}
.particle:nth-child(1) { left: 20%; animation-delay: 0s; animation-duration: 15s; }
.particle:nth-child(2) { left: 40%; animation-delay: 5s; animation-duration: 20s; background: #7c3aed; box-shadow: 0 0 10px #7c3aed; }
.particle:nth-child(3) { left: 60%; animation-delay: 10s; animation-duration: 25s; background: #a78bfa; box-shadow: 0 0 10px #a78bfa; }
.particle:nth-child(4) { left: 80%; animation-delay: 15s; animation-duration: 18s; }
.particle:nth-child(5) { left: 10%; animation-delay: 8s; animation-duration: 22s; background: #7c3aed; box-shadow: 0 0 10px #7c3aed; }
@keyframes float {
    0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
}

/* Snowfall animation */
.particle.snowflake {
    border-radius: 50%;
    box-shadow: 0 0 8px #fff;
    position: absolute;
    animation: snow-fall linear infinite;
}
@keyframes snow-fall {
    0% { transform: translateY(-10vh); opacity: 0.8; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { transform: translateY(110vh); opacity: 0.2; }
}
#snow-canvas { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:0; }
.chat-messages, .chat-bubble { position:relative; z-index:2; } /* ƒë·∫£m b·∫£o tuy·∫øt kh√¥ng ƒë√® l√™n */
    </style>
    <style>
      @media (max-width:600px) {
        /* Popup tool panel */
        #tool-buttons {
          position:absolute;
          bottom:100%;           /* n·∫±m tr√™n input */
          right:0;
          left:auto;
          display:flex;
          flex-direction:column; /* x·∫øp d·ªçc */
          gap:10px;
          padding:10px 12px;
          background:rgba(13,17,23,0.95);
          border:1px solid var(--border-color);
          border-radius:14px;
          box-shadow:0 8px 28px -4px rgba(0,0,0,0.55);
          backdrop-filter:blur(6px);
          transform-origin: bottom right;
          transition: opacity .18s ease, transform .18s ease;
          z-index:120;
          width:66px; /* ƒë·ªß cho icon vu√¥ng */
        }
        /* N·∫øu mu·ªën d·∫°ng 2 c·ªôt (b·ªè comment):
        #tool-buttons {
           width:134px;
           flex-wrap:wrap;
           flex-direction:row;
        }
        #tool-buttons .action-btn { flex:0 0 calc(50% - 6px); }
        */

        #tool-buttons .action-btn {
          width:52px;
          height:52px;
          font-size:20px;
          border:1px solid var(--border-color);
          border-radius:12px;
          background:#161b22;
          transition:background .18s, border-color .18s, color .18s;
        }
        #tool-buttons .action-btn:hover {
          background:#1f2731;
          border-color:var(--accent-color);
          color:var(--text-color);
        }

        #tool-buttons.collapsed {
          opacity:0;
          transform:translateY(10px) scale(.92);
          pointer-events:none;
        }
        #tool-buttons:not(.collapsed) {
          opacity:1;
          transform:translateY(0) scale(1);
        }

        /* CƒÉn n√∫t + s√°t b√™n ph·∫£i ƒë·ªÉ panel m·ªü l√™n ngay tr√™n */
        .input-actions {
          position:relative;
        }
        #toggle-tools-btn {
          position:relative;
          z-index:121; /* n·∫±m tr√™n panel */
        }
      }
    </style>
    <style>
/* === 3D Tilt Effect (buttons) === */
.tilt-3d{
  position:relative;
  background:linear-gradient(145deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01));
  box-shadow:0 4px 10px -2px rgba(0,0,0,0.45), 0 0 0 1px var(--border-color);
  transform-style:preserve-3d;
  will-change:transform;
  transition:transform .28s cubic-bezier(.25,.8,.25,1), box-shadow .35s;
  border-radius:8px;
}
.tilt-3d:hover{
  box-shadow:
    0 6px 18px -4px rgba(0,0,0,0.55),
    0 0 0 1px rgba(47,129,247,0.55),
    0 0 14px -2px rgba(47,129,247,0.55);
}
.tilt-3d::after{
  content:'';
  position:absolute;
  inset:0;
  background:
    radial-gradient(circle at var(--mx,50%) var(--my,50%),
      rgba(255,255,255,0.28),
      rgba(255,255,255,0.05) 38%,
      rgba(255,255,255,0) 70%);
  opacity:var(--glow-o,0);
  mix-blend-mode:screen;
  pointer-events:none;
  transition:opacity .25s;
  border-radius:inherit;
}
.tilt-3d:active{
  transition:transform .08s;
  transform:perspective(800px) rotateX(0deg) rotateY(0deg) translateZ(0) scale(.95);
}
</style>
<!-- Ensure the drawer toggle appears on mobile only -->
<style>
  @media (max-width:600px){
    #history-drawer-toggle { display: inline-flex; }
    .mobile-header { display: flex; }
  }
</style>
</head>
<body>
    <div class="bg-animation">
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
    </div>
    <div class="chat-container">
        <!-- (X√ìA n√∫t c≈© ·ªü ƒë√¢y n·∫øu c√≤n) -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <button class="new-chat-btn" onclick="startNewConversation()" title="Cu·ªôc tr√≤ chuy·ªán m·ªõi (Ctrl+Shift+X)">
                    <i class="fas fa-plus"></i>
                    <span>Cu·ªôc tr√≤ chuy·ªán m·ªõi</span>
                </button>
                <button id="find-btn" class="new-chat-btn" onclick="openFindModal()" title="T√¨m trong cu·ªôc tr√≤ chuy·ªán (Ctrl+Shift+F)">
                  <i class="fas fa-search"></i>
                  <span>T√¨m ki·∫øm</span>
                  <span style="margin-left:auto;font-size:11px;opacity:.6;">Ctrl+Shift+F</span>
                </button>
            </div>
            <nav class="history">
                <h3>
                    L·ªãch s·ª≠
                    <span id="history-actions" style="font-size:12px;"></span>
                </h3>
                <ul id="history-list"></ul>
            </nav>
            <div class="sidebar-footer">Made with ‚ù§Ô∏è by TT1403 & Ant.</div>
        </aside>

        <div class="resizer" id="resizer"></div>
        <div class="sidebar-backdrop" id="sidebar-backdrop"></div>
 
         <main class="chat-area" id="chat-area">
            <canvas id="snow-canvas"></canvas>
            <!-- N√∫t toggle l·ªãch s·ª≠ m·ªõi (mobile) -->
            <button id="history-drawer-toggle" class="history-top-toggle" aria-label="M·ªü l·ªãch s·ª≠">
                <span class="bars" aria-hidden="true">
                    <span class="bar"></span>
                    <span class="bar"></span>
                    <span class="bar"></span>
                </span>
            </button>
            <!-- Mobile header (shown on small screens) -->
            <div class="mobile-header" id="mobile-header">
                <button class="hamburger" id="mobile-menu-btn" aria-label="M·ªü menu"><i class="fas fa-bars"></i></button>
                <div class="title">JAREMIS</div>
                <button id="history-toggle-btn" aria-label="Xem l·ªãch s·ª≠" onclick="toggleHistoryMode()">
                    <i class="fas fa-clock-rotate-left"></i><span style="margin-left:4px;">L·ªãch s·ª≠</span>
                </button>
            </div>
             <!-- Auth controls (top-right) -->
             <div class="auth-controls" id="auth-controls">
                 <!-- Will be populated by JS -->
             </div>
 
            <div class="chat-messages" id="chat-messages">
                <div style="height:12px;"></div> <!-- spacer tr√°nh tr√πng n√∫t auth -->
                <div class="chat-bubble bot-bubble">
                    <strong>Ch√†o b·∫°n üëã M√¨nh l√† JAREMIS.</strong>
                    <p style="margin-top:8px; color:var(--text-secondary-color);">
                        H√£y nh·∫≠p c√°c d·∫•u hi·ªáu, h·ªèi chuy·ªán, ho·∫∑c b·∫≠t ch·∫ø ƒë·ªô <strong>Diagnose</strong> ƒë·ªÉ y√™u c·∫ßu ch·∫©n ƒëo√°n y khoa.
                    </p>
                </div>
            </div>

            <div class="chat-input-area">
                <div id="image-preview-container"></div>
                <div class="input-wrapper">
                    <textarea id="chat-input" placeholder="Nh·∫≠p tin nh·∫Øn ho·∫∑c t·∫£i l√™n h√¨nh ·∫£nh..." rows="1" oninput="autoResize(this)"></textarea>

                    <div class="input-actions">
                        <button id="toggle-tools-btn" class="toggle-tools-btn" title="M·ªü c√¥ng c·ª•" onclick="toggleToolTray(event)">
                            <i class="fas fa-plus"></i>
                        </button>

                        <div id="tool-buttons" class="tool-buttons collapsed">
                            <button class="action-btn" id="attach-btn" onclick="document.getElementById('images').click()" title="ƒê√≠nh k√®m ·∫£nh (Ctrl+Shift+U)">
                                <i class="fas fa-paperclip"></i>
                            </button>
                            <button id="mode-btn" class="action-btn" title="Ch·∫ø ƒë·ªô: Chat (Ctrl+Shift+K)" onclick="toggleMode(event)">
                                <i class="fas fa-comments"></i>
                            </button>
                            <button id="mic-btn" class="action-btn" title="Ghi gi·ªçng n√≥i (Ctrl+M). Nh·∫•n ƒë·ªÉ b·∫Øt ƒë·∫ßu/d·ª´ng" onclick="toggleMic(event)">
                                <i class="fas fa-microphone"></i>
                                <span id="mic-indicator"></span>
                            </button>
                            <button id="think-btn" class="action-btn" title="B·∫≠t Think (Ctrl+Shift+Y)" onclick="toggleThink(event)">
                                <i class="fas fa-brain"></i>
                            </button>
                        </div>

                        <button id="send-btn" class="action-btn" onclick="submitData()" title="G·ª≠i (Enter)">
                            <i class="fas fa-paper-plane"></i>
                        </button>

                        <input type="file" id="images" multiple hidden onchange="handleImageUpload(event)">
                    </div>
                </div>

                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div id="model-status">Model: JAREMIS 1.5</div>
                    <div style="font-size:12px; color:var(--text-secondary-color);">Tr·∫°ng th√°i: R·∫£nh</div>
                </div>
            </div>
        </main>
    </div>

    <!-- Auth modal -->
    <div class="modal-backdrop" id="auth-backdrop">
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="auth-title">
            <h3 id="auth-title">ƒêƒÉng nh·∫≠p / ƒêƒÉng k√Ω</h3>

            <div class="tabs">
                <div class="tab active" id="tab-login" onclick="showTab('login')">ƒêƒÉng nh·∫≠p</div>
                <div class="tab" id="tab-register" onclick="showTab('register')">ƒêƒÉng k√Ω</div>
            </div>

            <!-- Login form -->
            <div id="form-login">
                <div class="form-row">
                    <label>Username ho·∫∑c Email</label>
                    <input id="login-username" placeholder="T√™n ƒëƒÉng nh·∫≠p ho·∫∑c email">
                </div>
                <div class="form-row">
                    <label>M·∫≠t kh·∫©u</label>
                    <input id="login-password" type="password" placeholder="M·∫≠t kh·∫©u">
                </div>
                <div class="form-row">
                    <button class="btn-primary" onclick="submitLogin()">ƒêƒÉng nh·∫≠p</button>
                    <button class="btn-primary" onclick="loginWithGoogle()" style="background-color: #4285F4;"> <i class="fab fa-google"></i> Google</button>
                    <button class="btn-primary" onclick="loginWithFacebook()" style="background-color: #3b5998;"> <i class="fab fa-facebook"></i> Facebook</button>
                </div>

                <div class="form-actions">
                    <button class="btn-ghost" onclick="closeAuthModal()">H·ªßy</button>
                </div>
                <div class="small-muted">B·∫°n ch∆∞a c√≥ t√†i kho·∫£n? Chuy·ªÉn sang tab "ƒêƒÉng k√Ω".</div>
            </div>

            <!-- Register form -->
            <div id="form-register" style="display:none">
                <div class="form-row">
                    <label>T√™n ƒëƒÉng nh·∫≠p</label>
                    <input id="reg-username" placeholder="T√™n ƒëƒÉng nh·∫≠p">
                </div>
                <div class="form-row">
                    <label>Email</label>
                    <input id="reg-email" placeholder="email@example.com" type="email">
                </div>
                <div class="form-row">
                    <label>M·∫≠t kh·∫©u</label>
                    <input id="reg-password" type="password" placeholder="M·∫≠t kh·∫©u (√≠t nh·∫•t 6 k√Ω t·ª±)">
                </div>

                <div class="form-actions">
                    <button class="btn-primary" onclick="submitRegister()">ƒêƒÉng k√Ω</button>
                    <button class="btn-ghost" onclick="closeAuthModal()">H·ªßy</button>
                </div>
                <div class="small-muted">B·∫±ng c√°ch ƒëƒÉng k√Ω, b·∫°n ƒë·ªìng √Ω th·ª≠ nghi·ªám t√≠nh nƒÉng.</div>
            </div>
        </div>
    </div>

    <div class="modal-backdrop" id="find-backdrop" style="display:none;">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="find-title">
        <h3 id="find-title" style="display:flex;justify-content:space-between;align-items:center;">
          <span>T√¨m ki·∫øm</span>
          <button class="btn-ghost" style="padding:4px 10px;font-size:14px;" onclick="closeFindModal()" title="ƒê√≥ng (Esc)">&times;</button>
        </h3>
        <div class="form-row" style="margin-bottom:10px;">
          <input id="find-query" placeholder="Nh·∫≠p t·ª´ kh√≥a... (Enter=Ti·∫øp, Shift+Enter=Tr∆∞·ªõc)" style="background:#071018;">
        </div>
        <div class="form-row" style="flex-direction:row;align-items:center;gap:14px;margin-bottom:12px;">
          <label style="display:flex;align-items:center;gap:6px;font-size:12px;">
            <input type="checkbox" id="find-case"> Ph√¢n bi·ªát hoa/th∆∞·ªùng
          </label>
          <div id="find-count" style="margin-left:auto;font-size:12px;color:var(--text-secondary-color);">0 / 0</div>
        </div>
        <div class="form-actions" style="justify-content:flex-start;gap:8px;">
          <button class="btn-ghost" onclick="findPrev()" title="Tr∆∞·ªõc (Shift+Enter)">Tr∆∞·ªõc</button>
          <button class="btn-primary" onclick="findNext()" title="Ti·∫øp (Enter)">Ti·∫øp</button>
          <button class="btn-ghost" onclick="clearFindHighlights()" title="X√≥a highlight">X√≥a</button>
          <button class="btn-ghost" onclick="closeFindModal()" title="ƒê√≥ng (Esc)">ƒê√≥ng</button>
        </div>
        <div class="small-muted" style="margin-top:10px;">
          Ctrl+F m·ªü ‚Ä¢ Enter=Ti·∫øp ‚Ä¢ Shift+Enter=Tr∆∞·ªõc ‚Ä¢ Esc=ƒê√≥ng
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        // ------------------------------
        // UI elements & state
        // ------------------------------
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');
        const imageInput = document.getElementById('images');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const chatMessages = document.getElementById('chat-messages');
        const thinkBtn = document.getElementById('think-btn');
        const modelStatusEl = document.getElementById('model-status');
        const micBtn = document.getElementById('mic-btn');
        const micIndicator = document.getElementById('mic-indicator');
        const modeBtn = document.getElementById('mode-btn');

        const historyListEl = document.getElementById('history-list');
        const historyActionsEl = document.getElementById('history-actions');

        const authBackdrop = document.getElementById('auth-backdrop');
        const authControls = document.getElementById('auth-controls');

        let useProModel = false;
        let diagnosticMode = false; // Chat mode default
        let recognition = null;
        let isRecording = false;
        let textBeforeRecording = '';
        let historyCache = [];

        let currentSessionId = null;

        // Config: optional timeout cap for the 'flash' model. 0 disables auto-stop.
        // Set e.g. window.FLASH_TIMEOUT_MS = 45000 to cap at 45s.
        window.FLASH_TIMEOUT_MS = window.FLASH_TIMEOUT_MS ?? 0;

        // Helpers required by inline handlers and rendering
        function escapeHtml(str){
          if (str === null || str === undefined) return '';
          return String(str)
            .replace(/&/g,'&amp;')
            .replace(/</g,'&lt;')
            .replace(/>/g,'&gt;')
            .replace(/"/g,'&quot;')
            .replace(/'/g,'&#039;');
        }
        function autoResize(el){
          if(!el) return;
          el.style.height = 'auto';
          const maxH = 200;
          el.style.height = Math.min(maxH, el.scrollHeight || 0) + 'px';
        }

        // Mobile sidebar (hamburger) behavior: open/close existing sidebar overlay (no new elements)
        (function(){
          const mobileBtn = document.getElementById('mobile-menu-btn');
          const drawerToggleBtn = document.getElementById('history-drawer-toggle');
          const sidebarEl = document.getElementById('sidebar');
          const backdrop = document.getElementById('sidebar-backdrop');
          if (!sidebarEl || !backdrop) return;

          function openSidebar(){
            sidebarEl.classList.add('mobile-open');
            backdrop.style.display = 'block';
            backdrop.classList.add('show');
            document.body.classList.add('no-scroll');
            if (mobileBtn) mobileBtn.setAttribute('aria-expanded','true');
            if (drawerToggleBtn) drawerToggleBtn.classList.add('open');
            setTimeout(()=>{ try{ sidebarEl.focus(); }catch(e){} },50);
          }

          function closeSidebar(){
            sidebarEl.classList.remove('mobile-open');
            backdrop.classList.remove('show');
            backdrop.style.display = 'none';
            document.body.classList.remove('no-scroll');
            if (mobileBtn) mobileBtn.setAttribute('aria-expanded','false');
            if (drawerToggleBtn) drawerToggleBtn.classList.remove('open');
          }

          if (mobileBtn) {
            mobileBtn.addEventListener('click', function(e){
              e && e.preventDefault();
              if (sidebarEl.classList.contains('mobile-open')) closeSidebar();
              else openSidebar();
            });
          }

          if (drawerToggleBtn) {
            drawerToggleBtn.addEventListener('click', function(e){
              e && e.preventDefault();
              if (sidebarEl.classList.contains('mobile-open')) closeSidebar();
              else openSidebar();
            });
          }

          backdrop.addEventListener('click', function(){ closeSidebar(); });

          document.addEventListener('keydown', function(e){
            if (e.key === 'Escape' && sidebarEl.classList.contains('mobile-open')) closeSidebar();
          });

          if (historyListEl){
            historyListEl.addEventListener('click', function(e){
              const li = e.target.closest && e.target.closest('li');
              if (!li) return;
              setTimeout(closeSidebar, 120);
            });
          }

          function debounce(fn, ms){ let t; return function(){ clearTimeout(t); t = setTimeout(fn, ms); }; }
          window.addEventListener('resize', debounce(function(){ if (window.innerWidth > 600) closeSidebar(); }, 180));
        })();

        // ------------------------------
        function toggleMode(e) {
            e?.preventDefault();
            diagnosticMode = !diagnosticMode;
            if (diagnosticMode) {
                modeBtn.classList.add('active');
                modeBtn.title = 'Ch·∫ø ƒë·ªô: Diagnose (ch·∫©n ƒëo√°n y khoa)';
                modeBtn.innerHTML = '<i class="fas fa-stethoscope"></i>';
            } else {
                modeBtn.classList.remove('active');
                modeBtn.title = 'Ch·∫ø ƒë·ªô: Chat';
                modeBtn.innerHTML = '<i class="fas fa-comments"></i>';
            }
        }

        function toggleThink(e) {
            e?.preventDefault();
            useProModel = !useProModel;
            if (useProModel) {
                thinkBtn.classList.add('active');
                modelStatusEl.textContent = 'Model: JAREMIS PRO 1.5';
            } else {
                thinkBtn.classList.remove('active');
                modelStatusEl.textContent = 'Model: JAREMIS 1.5';
            }
        }

        // ------------------------------
        // Authentication & user state (client session stored in localStorage)
        // ------------------------------
        document.addEventListener('DOMContentLoaded', () => {
            renderAuthControls();
            const u = getLocalUser();
            if (u) fetchAndRenderHistory(u.username);
            // Restore anonymous session to keep context between page reloads
            try {
                const savedSess = localStorage.getItem('jaremis_session');
                if (savedSess) currentSessionId = savedSess;
            } catch(_) {}
        });

        function getLocalUser() {
            try {
                const raw = localStorage.getItem('jaremis_user');
                if (!raw) return null;
                return JSON.parse(raw);
            } catch (e) {
                return null;
            }
        }

        function renderAuthControls() {
            authControls.innerHTML = '';
            const user = getLocalUser();
            if (user) {
                const nameEl = document.createElement('div');
                nameEl.style.color = 'var(--text-color)';
                nameEl.style.fontSize = '13px';
                nameEl.textContent = user.username;

                const btnHistoryClear = document.createElement('button');
                btnHistoryClear.className = 'auth-btn';
                btnHistoryClear.textContent = 'X√≥a l·ªãch s·ª≠';
                btnHistoryClear.title = 'X√≥a to√†n b·ªô l·ªãch s·ª≠ chat';
                btnHistoryClear.onclick = async () => {
                    if (!confirm('X√≥a to√†n b·ªô l·ªãch s·ª≠ chat c·ªßa b·∫°n?')) return;
                    try {
                        const res = await fetch(`/api/history?username=${encodeURIComponent(user.username)}`, { method: 'DELETE' });
                        const json = await res.json();
                        if (!res.ok) {
                            alert(json.error || 'Kh√¥ng x√≥a ƒë∆∞·ª£c l·ªãch s·ª≠');
                            return;
                        }
                        historyCache = [];
                        renderHistoryList([]);
                        flashNotice('ƒê√£ x√≥a l·ªãch s·ª≠');
                    } catch (e) {
                        console.error(e);
                        flashNotice('L·ªói khi x√≥a l·ªãch s·ª≠');
                    }
                };

                const logoutBtn = document.createElement('button');
                logoutBtn.className = 'auth-btn';
                logoutBtn.textContent = 'ƒêƒÉng xu·∫•t';
                logoutBtn.onclick = () => {
                    try { localStorage.removeItem('jaremis_user'); } catch(e) {}
                    renderAuthControls();
                    historyCache = [];
                    renderHistoryList([]);
                };

                authControls.appendChild(nameEl);
                authControls.appendChild(btnHistoryClear);
                authControls.appendChild(logoutBtn);
            } else {
                const loginBtn = document.createElement('button');
                loginBtn.className = 'auth-btn';
                loginBtn.textContent = 'ƒêƒÉng nh·∫≠p';
                loginBtn.onclick = openAuthModal;

                const registerBtn = document.createElement('button');
                registerBtn.className = 'auth-btn';
                registerBtn.textContent = 'ƒêƒÉng k√Ω';
                registerBtn.onclick = () => { openAuthModal(); showTab('register'); };

                authControls.appendChild(loginBtn);
                authControls.appendChild(registerBtn);
            }
        }

        function openAuthModal() {
            authBackdrop.style.display = 'flex';
            showTab('login');
        }
        function closeAuthModal() {
            authBackdrop.style.display = 'none';
        }
        function showTab(tab) {
            document.getElementById('tab-login').classList.toggle('active', tab === 'login');
            document.getElementById('tab-register').classList.toggle('active', tab === 'register');
            document.getElementById('form-login').style.display = tab === 'login' ? 'block' : 'none';
            document.getElementById('form-register').style.display = tab === 'register' ? 'block' : 'none';
        }

        async function submitRegister() {
            const username = document.getElementById('reg-username').value.trim();
            const email = document.getElementById('reg-email').value.trim();
            const password = document.getElementById('reg-password').value;

            if (!username || !email || !password) {
                flashNotice('Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin ƒëƒÉng k√Ω');
                return;
            }
            if (password.length < 6) {
                flashNotice('M·∫≠t kh·∫©u √≠t nh·∫•t 6 k√Ω t·ª±');
                return;
            }

            try {
                const res = await fetch('/api/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, email, password })
                });
                const json = await res.json();
                if (!res.ok) {
                    flashNotice(json.error || 'ƒêƒÉng k√Ω th·∫•t b·∫°i');
                    return;
                }
                localStorage.setItem('jaremis_user', JSON.stringify(json.user));
                flashNotice('ƒêƒÉng k√Ω th√†nh c√¥ng! B·∫°n ƒë√£ ƒëƒÉng nh·∫≠p t·∫°m th·ªùi.', 2000);
                closeAuthModal();
                renderAuthControls();
                fetchAndRenderHistory(json.user.username);
            } catch (e) {
                console.error('Register error', e);
                flashNotice('L·ªói k·∫øt n·ªëi khi ƒëƒÉng k√Ω');
            }
        }

        async function submitLogin() {
            const usernameOrEmail = document.getElementById('login-username').value.trim();
            const password = document.getElementById('login-password').value;
            if (!usernameOrEmail || !password) {
                flashNotice('Vui l√≤ng nh·∫≠p username/email v√† m·∫≠t kh·∫©u');
                return;
            }
            try {
                const res = await fetch('/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ usernameOrEmail, password })
                });
                const json = await res.json();
                if (!res.ok) {
                    flashNotice(json.error || 'ƒêƒÉng nh·∫≠p th·∫•t b·∫°i');
                    return;
                }
                localStorage.setItem('jaremis_user', JSON.stringify(json.user));
                flashNotice('ƒêƒÉng nh·∫≠p th√†nh c√¥ng', 1200);
                closeAuthModal();
                renderAuthControls();
                fetchAndRenderHistory(json.user.username);
            } catch (e) {
                console.error('Login error', e);
                flashNotice('L·ªói k·∫øt n·ªëi khi ƒëƒÉng nh·∫≠p');
            }
        }

        // New: Login with Google
        function loginWithGoogle() {
            window.location.href = '/auth/google';
        }

        // New: Login with Facebook
        function loginWithFacebook() {
            window.location.href = '/auth/facebook';
        }

        function flashNotice(msg, duration = 2000) {
            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble bot-bubble';
            bubble.innerHTML = `<em style="color:var(--text-secondary-color)">${escapeHtml(msg)}</em>`;
            chatMessages.appendChild(bubble);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            setTimeout(() => bubble.remove(), duration);
        }

        // ------------------------------
        // History: fetch, render, open
        // ------------------------------
        async function fetchAndRenderHistory(username) {
            if (!username) return;
            try {
                const res = await fetch(`/api/history?username=${encodeURIComponent(username)}`);
                const json = await res.json();
                if (!res.ok) {
                    console.warn('Kh√¥ng l·∫•y ƒë∆∞·ª£c l·ªãch s·ª≠', json);
                    renderHistoryList([]);
                    return;
                }
                historyCache = json.history || [];
                renderHistoryList(historyCache);
            } catch (e) {
                console.error('fetch history error', e);
            }
        }

        // Group & render history th√†nh LIST CU·ªòC TR√í CHUY·ªÜN
        function renderHistoryList(list) {
          historyListEl.innerHTML = '';
          if (!list || list.length === 0) {
            historyListEl.innerHTML = `<li style="color:var(--text-secondary-color); font-size:13px;">Ch∆∞a c√≥ l·ªãch s·ª≠</li>`;
            historyActionsEl.innerHTML = '';
            return;
          }
          // Gom theo sessionId
          const sessions = {};
          list.forEach(entry => {
            const sid = entry.sessionId || ('legacy-' + entry.id);
            if (!sessions[sid]) sessions[sid] = [];
            sessions[sid].push(entry);
          });
          // S·∫Øp x·∫øp session theo newest timestamp (l·ªõn nh·∫•t)
          const sessionArray = Object.entries(sessions).map(([sid, entries]) => {
            const newestTs = Math.max(...entries.map(e => new Date(e.timestamp).getTime()));
            return { sid, entries, newestTs };
          }).sort((a,b) => b.newestTs - a.newestTs);

          sessionArray.forEach(sess => {
            // L·∫•y message user ƒë·∫ßu ti√™n c·ªßa session (c≈© nh·∫•t type chat/diagnose c√≥ input)
            const chronological = [...sess.entries].sort((a,b)=> new Date(a.timestamp)-new Date(b.timestamp));
            const first = chronological.find(e => e.input && e.input.trim()) || chronological[chronological.length-1];
            const title = (first.input || 'Cu·ªôc tr√≤ chuy·ªán').slice(0,60) + (first.input && first.input.length>60 ? '...' : '');
            const timeLabel = new Date(sess.newestTs).toLocaleString();
            const li = document.createElement('li');
            li.dataset.session = sess.sid;
            li.innerHTML = `<div style="display:flex; flex-direction:column; gap:4px;">
                <div style="font-size:13px; color:var(--text-color); font-weight:600;">${escapeHtml(title)}</div>
                <div style="font-size:11px; color:var(--text-secondary-color);">${escapeHtml(timeLabel)} ‚Ä¢ ${sess.entries.length} l∆∞·ª£t</div>
              </div>`;
            li.onclick = () => openConversation(sess.sid);
            historyListEl.appendChild(li);
          });
          historyActionsEl.innerHTML = ''; // b·ªè n√∫t c≈©
        }

        // M·ªü to√†n b·ªô cu·ªôc tr√≤ chuy·ªán
        function openConversation(sessionId) {
          const convoEntries = historyCache.filter(e => (e.sessionId || ('legacy-'+e.id)) === sessionId)
            .sort((a,b)=> new Date(a.timestamp)-new Date(b.timestamp));
          if (!convoEntries.length) return;
          chatMessages.innerHTML = '';
          convoEntries.forEach(entry => {
            // User bubble
            if (entry.input) {
              chatMessages.innerHTML += `<div class="chat-bubble user-bubble"><div class="user-bubble-content"><p>${escapeHtml(entry.input)}</p></div></div>`;
            }
            // Bot / k·∫øt qu·∫£
            if (entry.type === 'diagnose') {
              chatMessages.innerHTML += `<div class="chat-bubble bot-bubble">
                <div class="diagnosis-details">
                  <div style="font-size:12px; color:var(--text-secondary-color); margin-bottom:6px;">Diagnose ‚Ä¢ ${new Date(entry.timestamp).toLocaleString()}</div>
                  ${convertMarkdown(entry.diagnosis || '')}
                </div>
              </div>`;
            } else {
              chatMessages.innerHTML += `<div class="chat-bubble bot-bubble">
                <div class="diagnosis-details">
                  <div style="font-size:12px; color:var(--text-secondary-color); margin-bottom:6px;">Chat ‚Ä¢ ${new Date(entry.timestamp).toLocaleString()}</div>
                  ${convertMarkdown(entry.reply || '')}
                </div>
              </div>`;
            }
          });
          chatMessages.scrollTop = chatMessages.scrollHeight;
          currentSessionId = sessionId; // ti·∫øp t·ª•c v√†o phi√™n n√†y n·∫øu ng∆∞·ªùi d√πng mu·ªën
          localStorage.setItem('jaremis_session', currentSessionId);
        }

        // ------------------------------
        // Mic / SpeechRecognition
        // ------------------------------
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition || null;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.lang = 'vi-VN';
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;
            recognition.continuous = false;

            recognition.onstart = () => {
                isRecording = true;
                micBtn.classList.add('recording');
                micBtn.title = 'ƒêang ghi √¢m ‚Äî nh·∫•n ƒë·ªÉ d·ª´ng';
                textBeforeRecording = chatInput.value || '';
                chatInput.focus();
            };

            recognition.onerror = (event) => {
                console.warn('Speech recognition error', event.error);
                stopRecognition();
                flashNotice('L·ªói ghi √¢m: ' + (event.error || 'Kh√¥ng x√°c ƒë·ªãnh'));
            };

            recognition.onend = () => {
                stopRecognition(false);
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';
                for (let i = 0; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript += transcript;
                    }
                }
                chatInput.value = (textBeforeRecording + ' ' + finalTranscript + interimTranscript).trim();
                autoResize(chatInput);
            };
        } else {
            micBtn.title = 'Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ghi √¢m chuy·ªÉn vƒÉn b·∫£n (Web Speech API). D√πng Chrome/Microsoft Edge m·ªõi nh·∫•t ƒë·ªÉ c√≥ ch·ª©c nƒÉng n√†y.';
            micBtn.style.opacity = '0.6';
            micBtn.style.pointerEvents = 'none';
        }

        function toggleMic(e) {
            e?.preventDefault();
            if (!SpeechRecognition) return;
            if (!isRecording) startRecognition();
            else stopRecognition();
        }

        function startRecognition() {
            if (!recognition) return;
            try {
                textBeforeRecording = chatInput.value || '';
                recognition.start();
            } catch (err) {
                console.warn('Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu ghi √¢m:', err);
                flashNotice('Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu ghi √¢m: ' + (err.message || err));
            }
        }

        function stopRecognition(clearInterim = false) {
            if (!recognition) return;
            try { recognition.stop(); } catch (e) {}
            isRecording = false;
            micBtn.classList.remove('recording');
            micBtn.title = 'Ghi gi·ªçng n√≥i (Vietnamese). Nh·∫•n ƒë·ªÉ b·∫Øt ƒë·∫ßu/d·ª´ng';
            if (clearInterim) {
                chatInput.value = textBeforeRecording || '';
                autoResize(chatInput);
            }
        }

        // ------------------------------
        // Image preview
        // ------------------------------
        function handleImageUpload(event) {
            imagePreviewContainer.innerHTML = '';
            Array.from(event.target.files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = e => {
                    const div = document.createElement('div');
                    div.className = 'preview-item';
                    div.innerHTML = `
                        <img src="${e.target.result}" alt="Preview">
                        <button class="remove-btn" onclick="removeImage(${index})">&times;</button>
                    `;
                    imagePreviewContainer.appendChild(div);
                };
                reader.readAsDataURL(file);
            });
        }

        function removeImage(index) {
            const dt = new DataTransfer();
            const files = Array.from(imageInput.files);
            files.splice(index, 1);
            files.forEach(file => dt.items.add(file));
            imageInput.files = dt.files;
            handleImageUpload({ target: imageInput });
        }

        // ------------------------------
        // Animate analysis steps (UX)
        // ------------------------------
        async function animateAnalysisSteps(bubbleElement) {
            const steps = [
                'ƒêang kh·ªüi t·∫°o v√† g·ª≠i d·ªØ li·ªáu...',
                'T√¨m ki·∫øm t√†i li·ªáu tham kh·∫£o (PubMed, ClinicalTrials)...',
                'AI ƒëang ph√¢n t√≠ch v√† ch·∫©n ƒëo√°n h√¨nh ·∫£nh...',
                'T·ªïng h·ª£p v√† ƒë·ªãnh d·∫°ng k·∫øt qu·∫£ ch·∫©n ƒëo√°n...'
            ];

            let html = '<div class="analysis-steps">';
            steps.forEach((step, index) => {
                html += `<div id="step-${index}" class="step-item pending">
                            <span class="icon"><i class="fas fa-hourglass-half"></i></span>
                            <span>${step}</span>
                         </div>`;
            });
            html += '</div>';
            bubbleElement.innerHTML = html;

            for (let i = 0; i < steps.length; i++) {
                const stepEl = bubbleElement.querySelector(`#step-${i}`);
                const iconEl = stepEl.querySelector('.icon');

                stepEl.classList.remove('pending');
                stepEl.classList.add('active');
                iconEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                await new Promise(resolve => setTimeout(resolve, 600 + Math.random() * 600));

                stepEl.classList.remove('active');
                stepEl.classList.add('completed');
                iconEl.innerHTML = '<i class="fas fa-check"></i>';
            }
        }

        // ------------------------------
        // Submit: chooses /api/chat or /api/diagnose
        // ------------------------------
        async function submitData() {
            // Prevent double-submit, but recover from stale/aborted controllers
            if (window._currentAbortController) {
                try {
                    const sig = window._currentAbortController.signal;
                    const startedAt = window._currentAbortStartedAt || 0;
                    const tooLong = Date.now() - startedAt > 20000; // 20s safety
                    if (sig && sig.aborted) {
                        window._currentAbortController = null;
                        window._currentAbortStartedAt = 0;
                    } else if (tooLong) {
                        // reset stuck state
                        try { window._currentAbortController.abort(); } catch(e) {}
                        window._currentAbortController = null;
                        window._currentAbortStartedAt = 0;
                    } else {
                        // still in-progress -> ignore new send
                        flashNotice && flashNotice('ƒêang x·ª≠ l√Ω ph·∫£n h·ªìi tr∆∞·ªõc, h√£y ƒë·ª£i ho·∫∑c nh·∫•n n√∫t d·ª´ng.');
                        return;
                    }
                } catch (e) {
                    window._currentAbortController = null;
                    window._currentAbortStartedAt = 0;
                }
            }
            const labResults = chatInput.value.trim();
            const images = imageInput.files;
            if (!labResults && images.length === 0) return;
            if (!currentSessionId) {
                currentSessionId = 'sess-' + Date.now();
                localStorage.setItem('jaremis_session', currentSessionId);
            }

            // Build user bubble
            let userHtml = `<div class="chat-bubble user-bubble"><div class="user-bubble-content">`;
            if (labResults) userHtml += `<p>${escapeHtml(labResults)}</p>`;
            if (images.length > 0) {
                let imagePreviews = '<div class="user-images-preview">';
                for (let i = 0; i < images.length; i++) {
                    imagePreviews += `<img src="${URL.createObjectURL(images[i])}" alt="user image">`;
                }
                imagePreviews += '</div>';
                userHtml += imagePreviews;
            }
            const currentUser = getLocalUser();
            if (currentUser) {
                userHtml += `<div style="margin-top:8px; font-size:12px; color:var(--text-secondary-color)">ƒê√£ g·ª≠i b·ªüi: ${escapeHtml(currentUser.username)}</div>`;
            }
            userHtml += `</div></div>`;
            chatMessages.innerHTML += userHtml;

            // Clear input + previews
            chatInput.value = '';
            autoResize(chatInput);
            imagePreviewContainer.innerHTML = '';

            // Create loading bubble
            const loadingBubble = document.createElement('div');
            loadingBubble.className = 'chat-bubble bot-bubble';
            chatMessages.appendChild(loadingBubble);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            // Setup AbortController so user can stop the response
            const controller = new AbortController();
            window._currentAbortController = controller;
            window._currentAbortStartedAt = Date.now();

            // Toggle send button into stop button
            try {
                sendBtn.dataset.prevHtml = sendBtn.innerHTML || '';
                sendBtn.dataset.prevTitle = sendBtn.title || '';
                sendBtn.innerHTML = '<i class="fas fa-stop"></i>';
                sendBtn.title = 'D·ª´ng AI (Ctrl+Enter)';
                sendBtn.onclick = function(e){ e?.preventDefault(); if (window._currentAbortController) window._currentAbortController.abort(); };
            } catch (e) {}

            // Implement 15s timeout for flash model
            let flashTimeoutId = null;
            const modelName = useProModel ? 'pro' : 'flash';
            const timeoutMs = (window.FLASH_TIMEOUT_MS ?? 0);
            if (modelName === 'flash' && timeoutMs > 0) {
                // stop if too slow
                flashTimeoutId = setTimeout(() => {
                    try {
                        if (window._currentAbortController) {
                            window._currentAbortController.abort();
                            flashNotice && flashNotice(`Flash model exceeded ${timeoutMs}ms timeout and was stopped.`);
                        }
                    } catch (e) { /* ignore */ }
                }, timeoutMs);
            }

            try {
                // Show thinking animation while the model is responding
                startThinking(loadingBubble);

                if (diagnosticMode) {
                    const formData = new FormData();
                    if (labResults) formData.append('labResults', labResults);
                    Array.from(images).forEach(img => formData.append('images', img));
                    formData.append('model', modelName);
                    formData.append('sessionId', currentSessionId);
                    if (currentUser) formData.append('submittedBy', currentUser.username);

                    const resp = await fetch('/api/diagnose', { method: 'POST', body: formData, signal: controller.signal });
                    if (!resp.ok) {
                        const error = await resp.json().catch(()=>({error:'L·ªói t·ª´ server'}));
                        throw new Error(error.error || 'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ m√°y ch·ªß');
                    }
                    const data = await resp.json();
                    // Prefer server-rendered KaTeX HTML to avoid client-side parsing issues
                    const html = data.diagnosisHtml;
                    stopThinking(loadingBubble);
                    if (html) {

                        loadingBubble.innerHTML = `<div class="bot-reply">${html}</div>`;
                        try {
                            if (window.jaremis && typeof window.jaremis.ensureRenderMath === 'function') {
                                window.jaremis.ensureRenderMath(loadingBubble);
                            } else if (typeof window.renderMathIn === 'function') {
                                window.renderMathIn(loadingBubble);
                            }
                        } catch(_) {}
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } else {
                        const fallback = convertMarkdown(data.diagnosis || '');
                        await renderBotReplyAnimated(loadingBubble, fallback);
                    }
                    if (currentUser) fetchAndRenderHistory(currentUser.username);
                } else {
                    // Use the new streaming endpoint for chat mode
                    await streamChatResponse(labResults, images, modelName, currentUser, currentSessionId, loadingBubble, controller.signal);
                }
           
           
            } catch (err) {
                if (err && err.name === 'AbortError') {
                    flashNotice('AI response stopped');
                    loadingBubble.remove();
                } else {
                    showError(err.message || String(err), loadingBubble);
                }
            } finally {
                // cleanup
                clearTimeout(flashTimeoutId);
                               window._currentAbortController = null;
                window._currentAbortStartedAt = 0;
                try {
                    sendBtn.innerHTML = sendBtn.dataset.prevHtml || '<i class="fas fa-paper-plane"></i>';
                    sendBtn.title = sendBtn.dataset.prevTitle || 'G·ª≠i';
                    sendBtn.onclick = submitData;
                    delete sendBtn.dataset.prevHtml; delete sendBtn.dataset.prevTitle;
                } catch (e) {}
                imageInput.value = '';
            }
        }

        // New function to handle streaming chat responses
        async function streamChatResponse(message, images, model, user, sessionId, targetBubble, signal) {
            stopThinking(targetBubble); // Stop the "thinking..." animation
            targetBubble.innerHTML = ''; // Clear the bubble
            const container = document.createElement('div');
            container.className = 'bot-reply';
            targetBubble.appendChild(container);

            // Ensure request body matches backend expectations
            const body = { message, model, sessionId };
            if (user) body.submittedBy = user.username;
            if (images.length > 0) body.imagesCount = images.length;

            try {
                const response = await fetch('/api/chat-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                    signal: signal
                });

                // Improved error handling: parse backend error message
                if (!response.ok) {
                    const err = await response.json().catch(() => ({ error: 'Server error during streaming.' }));
                    let errorMsg = err.error || 'Failed to start stream.';
                    // Suggest common causes for streaming errors
                    errorMsg += '<br><span style="font-size:13px;color:var(--text-secondary-color)">C√≥ th·ªÉ do: API key h·∫øt h·∫°n, thi·∫øu key, v∆∞·ª£t quota, ho·∫∑c server ƒëang b·∫£o tr√¨.<br>Vui l√≤ng ki·ªÉm tra l·∫°i c·∫•u h√¨nh backend ho·∫∑c li√™n h·ªá h·ªó tr·ª£.</span>';
                    throw new Error(errorMsg);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullReply = '';
                let buffer = '';
                let finalReceived = false;
                let finalHtml = null;

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    
                    // Process buffer line by line for SSE messages
                    let boundary;
                    while ((boundary = buffer.indexOf('\n\n')) >= 0) {
                        const message = buffer.substring(0, boundary);
                        buffer = buffer.substring(boundary + 2);

                        if (message.startsWith('data: ')) {
                            try {
                                const jsonString = message.substring(6);
                                const data = JSON.parse(jsonString);
                                if (data.chunk) {
                                    fullReply += data.chunk;
                                    // During streaming, render as plain escaped text to avoid breaking LaTeX delimiters
                                    container.innerHTML = escapeHtml(fullReply).replace(/\n/g, '<br>');
                                    // Scroll to bottom as content is added
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                }
                                if (data.error) {
                                    container.innerHTML = `<div class="error-message">${escapeHtml(data.error)}</div>`;
                                    finalReceived = true;
                                }
                                if (data.done) {
                                    finalReceived = true;
                                    finalHtml = data.replyHtml || null;
                                }
                            } catch (e) {
                                console.error('Error parsing stream data:', e);
                            }
                        }
                    }
                }
                
                // Final render to catch any remaining buffer and apply KaTeX
                if (finalReceived && finalHtml) {
                    container.innerHTML = finalHtml;
                } else if (fullReply) {
                    container.innerHTML = marked.parse(fullReply);
                }
                if (window.jaremis && typeof window.jaremis.ensureRenderMath === 'function') {
                    window.jaremis.ensureRenderMath(targetBubble);
                } else if (typeof window.renderMathIn === 'function') {
                    window.renderMathIn(targetBubble);
                }
                chatMessages.scrollTop = chatMessages.scrollHeight;

                // Update history after the full response is received
                if (user) {
                    fetchAndRenderHistory(user.username);
                }

            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Streaming fetch error:', err);
                    container.innerHTML = `<div class="error-message">Error streaming response: ${escapeHtml(err.message)}</div>`;
                } else {
                    // If aborted, the finally block will handle cleanup.
                    // The partial message remains visible.
                }
            }
        }

        // Ensure Enter sends (unless Shift+Enter), and support Ctrl+Enter as send as well
        (function(){
            try {
                const ci = document.getElementById('chat-input');
                if (ci) {
                    ci.addEventListener('keydown', function(ev){
                        if (ev.key === 'Enter' && !ev.shiftKey) {
                            ev.preventDefault();
                            // If a response is in progress, Enter stops it; otherwise, it sends
                            if (window._currentAbortController) {
                                try { window._currentAbortController.abort(); } catch(e) {}
                            } else {
                                submitData();
                            }
                        } else if ((ev.key === 'Enter' && (ev.ctrlKey || ev.metaKey))) {
                            ev.preventDefault();
                            if (window._currentAbortController) {
                                try { window._currentAbortController.abort(); } catch(e) {}
                            } else {
                                submitData();
                            }
                        }
                    });
                }
            } catch(e){ console.warn(e); }
        })();

        // ------------------------------
        // UI helpers referenced by inline handlers
        // ------------------------------
        function toggleToolTray(e){
            e?.preventDefault();
            const panel = document.getElementById('tool-buttons');
            const btn = document.getElementById('toggle-tools-btn');
            if (!panel || !btn) return;
            const willOpen = panel.classList.contains('collapsed');
            panel.classList.toggle('collapsed');
            btn.classList.toggle('active');
            if (willOpen) {
                // close when clicking outside
                const onDocClick = (ev) => {
                    if (btn.contains(ev.target) || panel.contains(ev.target)) return;
                    panel.classList.add('collapsed');
                    btn.classList.remove('active');
                    document.removeEventListener('click', onDocClick, true);
                };
                // delay to avoid immediate closing by current click
                setTimeout(()=>document.addEventListener('click', onDocClick, true), 0);
            }
        }

        function toggleHistoryMode(){
            // For mobile: reuse the same sidebar overlay. Just toggle it.
            try {
                const topToggle = document.getElementById('history-drawer-toggle');
                const hdrBtn = document.getElementById('history-toggle-btn');
                if (topToggle) topToggle.click();
                if (hdrBtn) hdrBtn.classList.toggle('active');
            } catch(e){ console.warn('toggleHistoryMode error', e); }
        }

        function startNewConversation(){
            try {
                // create a fresh session id
                currentSessionId = 'sess-' + Date.now();
                try { localStorage.setItem('jaremis_session', currentSessionId); } catch(_) {}
                // reset UI messages to greeting
                chatMessages.innerHTML = '<div style="height:12px;"></div>'+
                  '<div class="chat-bubble bot-bubble">'+
                  '<strong>Ch√†o b·∫°n üëã M√¨nh l√† JAREMIS.</strong>'+
                  '<p style="margin-top:8px; color:var(--text-secondary-color);">H√£y nh·∫≠p c√°c d·∫•u hi·ªáu, h·ªèi chuy·ªán, ho·∫∑c b·∫≠t ch·∫ø ƒë·ªô <strong>Diagnose</strong> ƒë·ªÉ y√™u c·∫ßu ch·∫©n ƒëo√°n y khoa.</p>'+
                  '</div>';
                chatMessages.scrollTop = chatMessages.scrollHeight;
                // clear input & previews
                chatInput.value = '';
                autoResize(chatInput);
                imagePreviewContainer.innerHTML = '';
                // close sidebar if open (mobile)
                const sidebarEl = document.getElementById('sidebar');
                const backdrop = document.getElementById('sidebar-backdrop');
                if (sidebarEl && sidebarEl.classList.contains('mobile-open')){
                    sidebarEl.classList.remove('mobile-open');
                    if (backdrop){ backdrop.classList.remove('show'); backdrop.style.display='none'; }
                    const drawerBtn = document.getElementById('history-drawer-toggle');
                    if (drawerBtn) drawerBtn.classList.remove('open');
                }
            } catch(e){ console.warn('startNewConversation error', e); }
        }
        // ------------------------------
        // Missing helpers: thinking animation, typewriter reply, error display
        // These were referenced but not defined previously; implement robust versions
        // ------------------------------
        function startThinking(bubble){
            if(!bubble) return;
            try{ clearInterval(bubble._thinkInterval); }catch(e){}
            bubble.dataset.katexRendered = '0';
            bubble.innerHTML = '';
            const wrapper = document.createElement('div');
            wrapper.style.display = 'flex';
            wrapper.style.flexDirection = 'column';
            wrapper.style.gap = '8px';

            const text = document.createElement('div');
            text.className = 'thinking-text';
            text.style.color = 'var(--text-secondary-color)';
            text.style.fontSize = '14px';
            text.textContent = 'ƒëang suy nghƒ© l√¢u h∆°n ƒë·ªÉ gi√∫p b·∫°n h√†i l√≤ng h∆°n';

            const dots = document.createElement('div');
            dots.className = 'thinking-dots';
            dots.style.color = 'var(--text-secondary-color)';
            dots.style.fontSize = '14px';

            wrapper.appendChild(text);
            wrapper.appendChild(dots);
            bubble.appendChild(wrapper);

            let dcount = 0;
            bubble._thinkInterval = setInterval(()=>{
                dcount = (dcount + 1) % 4;
                const n = dcount === 0 ? 1 : dcount; // at least one dot
                dots.textContent = '.'.repeat(n);
            }, 400);
            bubble._thinking = true;
            return bubble._thinkInterval;
        }

        function stopThinking(bubble){
            try{
                if(bubble && bubble._thinkInterval) clearInterval(bubble._thinkInterval);
            }catch(e){}
            if(bubble){ bubble._thinking = false; }
        }

        function showError(message, targetBubble){
            console.error('showError:', message);
            if (targetBubble && targetBubble.parentNode) {
                targetBubble.innerHTML = `<div style="color:var(--error-color); font-weight:600;">L·ªói: ${escapeHtml(String(message))}</div>`;
            } else {
                const b = document.createElement('div');
                b.className = 'chat-bubble bot-bubble';
                b.innerHTML = `<div style="color:var(--error-color); font-weight:600;">L·ªói: ${escapeHtml(String(message))}</div>`;
                chatMessages.appendChild(b);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }

        // Simple markdown-ish converter used as fallback when server doesn't provide HTML
        function convertMarkdown(raw){
            if(!raw) return '';
            const maybeHtml = /<[^>]+>/g.test(raw);
            if(maybeHtml) return raw;
            let s = escapeHtml(raw);
            s = s.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1<\/a>');
            s = s.split(/\n\n+/).map(p => `<p>${p.replace(/\n/g,'<br>')}</p>`).join('');
            return s;
        }

        // Typewriter / progressive reveal for bot replies. Works with HTML by appending node-by-node and typing text-nodes.
        async function renderBotReplyAnimated(targetBubble, html){
            if(!targetBubble) return;
            stopThinking(targetBubble);
            targetBubble.innerHTML = '';
            const container = document.createElement('div');
            container.className = 'bot-reply';
            targetBubble.appendChild(container);

            // Gemini-like: reveal line-by-line (rows), with soft fade/slide and natural pauses.
            let fastForward = false;
            const onFast = () => {
                fastForward = true;
                // Instantly render the rest of the content
                container.innerHTML = html;
                // Make sure all child elements are visible instantly
                Array.from(container.children).forEach(child => child.classList.add('gemini-visible'));
                // And render any math
                try {
                    if (window.jaremis && typeof window.jaremis.ensureRenderMath === 'function') {
                        window.jaremis.ensureRenderMath(targetBubble);
                    } else if (typeof window.renderMathIn === 'function') {
                        window.renderMathIn(targetBubble);
                    }
                } catch(_){}
            };
            targetBubble.addEventListener('click', onFast, { once: true });

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            const cfg = {
                lineBase: window.GEMINI_LINE_BASE_MS ?? 80,          // base delay per line
                perChar: window.GEMINI_LINE_PER_CHAR_MS ?? 1.1,       // extra ms per char for rhythm
                sentencePause: window.GEMINI_SENTENCE_PAUSE_MS ?? 150, // extra pause after sentence-ending punctuation
                blockGap: window.GEMINI_BLOCK_GAP_MS ?? 120            // pause between major blocks (e.g. paragraphs)
            };

            function endsSentence(text){
                return /[\.!?‚Ä¶]\s*$/.test(text || '');
            }

            // Use marked.js to parse the markdown into a token stream
            const tokens = marked.lexer(html);
            const renderer = new marked.Renderer();

            for (const token of tokens) {
                if (fastForward) break;

                // Create a temporary list containing only the current token for the parser
                const singleTokenList = [token];
                singleTokenList.links = tokens.links; // Important: parser needs the links object

                const htmlFragment = marked.parser(singleTokenList, { renderer });

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlFragment.trim();

                const element = tempDiv.firstChild;

                if (element && element.nodeType === Node.ELEMENT_NODE) {
                    container.appendChild(element);

                    // Wait a frame for the element to be in the DOM but invisible
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    if (fastForward) break;

                    // Add class to trigger the CSS animation
                    element.classList.add('gemini-visible');

                    // Calculate dynamic delay for the next element
                    const text = element.textContent || '';
                    let delay = cfg.lineBase + text.length * cfg.perChar;
                    if (endsSentence(text)) {
                        delay += cfg.sentencePause;
                    }

                    await sleep(delay);
                } else if (htmlFragment.trim()) {
                    // Handle plain text nodes if any
                    const textNode = document.createTextNode(htmlFragment);
                    container.appendChild(textNode);
                    await sleep(cfg.lineBase);
                }
            }

            // If fast-forward was triggered, it already rendered everything.
            // If not, we just need to ensure math is rendered.
            if (!fastForward) {
                try {
                    if (window.jaremis && typeof window.jaremis.ensureRenderMath === 'function') {
                        window.jaremis.ensureRenderMath(targetBubble);
                    } else if (typeof window.renderMathIn === 'function') {
                        window.renderMathIn(targetBubble);
                    }
                } catch(_){}
            }

            // Clean up listener
            try { targetBubble.removeEventListener('click', onFast, { once: true }); } catch(_) {}
        }
     </script>
     <script>
/* === 3D Tilt Effect Script ===
   √Åp d·ª•ng cho: ƒëƒÉng nh·∫≠p / ƒëƒÉng xu·∫•t / x√≥a l·ªãch s·ª≠ (auth-btn),
   n√∫t Diagnose (#mode-btn), Jaremis Pro (#think-btn),
   ƒë√≠nh k√®m file (paperclip ‚Äì n√∫t action-btn ƒë·∫ßu ti√™n trong #tool-buttons),
   ghi √¢m (#mic-btn).
   Mu·ªën th√™m send: th√™m '#send-btn' v√†o SELECTORS.
*/
(function(){
  const SELECTORS = [
    '.auth-controls .auth-btn',        // ƒëƒÉng nh·∫≠p / ƒëƒÉng k√Ω / ƒëƒÉng xu·∫•t / x√≥a l·ªãch s·ª≠
    '#mode-btn',                       // Diagnose toggle
    '#think-btn',                      // Jaremis Pro
    '#mic-btn',                        // Mic
    '#tool-buttons .action-btn:first-child', // Paperclip
    '.new-chat-btn',                   // "Cu·ªôc tr√≤ chuy·ªán m·ªõi"
    '#send-btn',                       // G·ª≠i
    '.btn-primary',                    // N√∫t ƒêƒÉng nh·∫≠p / ƒêƒÉng k√Ω
    '.btn-ghost'                       // N√∫t H·ªßy
  ];
  const MAX_TILT = 14;
  const PERSPECTIVE = 800;
  function applyTilt(el){
    if(!el || el.dataset.tiltApplied) return;
    el.dataset.tiltApplied = '1';
    el.classList.add('tilt-3d');
    function move(e){
      const rect = el.getBoundingClientRect();
      const x = (e.clientX - rect.left)/rect.width;
      const y = (e.clientY - rect.top)/rect.height;
      const rotX = (0.5 - y) * (MAX_TILT * 2);
      const rotY = (x - 0.5) * (MAX_TILT * 2);
      el.style.setProperty('--mx', (x*100).toFixed(2)+'%');
      el.style.setProperty('--my', (y*100).toFixed(2)+'%');
      el.style.transform = `perspective(${PERSPECTIVE}px) rotateX(${rotX}deg) rotateY(${rotY}deg) translateZ(6px)`;
      el.style.setProperty('--glow-o','1');
    }
    function leave(){
      el.style.transform = `perspective(${PERSPECTIVE}px) rotateX(0deg) rotateY(0deg) translateZ(0)`;
      el.style.setProperty('--glow-o','0');
    }
    el.addEventListener('mousemove', move);
    el.addEventListener('mouseenter', move);
    el.addEventListener('mouseleave', leave);
    el.addEventListener('touchmove', (e)=>{
      const t = e.touches[0];
      move(t);
    }, {passive:true});
    el.addEventListener('touchend', leave);
  }
  function scan(){
    SELECTORS.forEach(sel=>{
      document.querySelectorAll(sel).forEach(applyTilt);
    });
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    scan();
    // Quan s√°t auth-controls v√¨ n√∫t ƒë∆∞·ª£c t·∫°o ƒë·ªông
    const auth = document.querySelector('.auth-controls');
    if(auth){
      new MutationObserver(scan).observe(auth,{childList:true,subtree:true});
    }
  });
})();
</script>
<script>
// ================= REALISTIC SNOW v2 (restored) =================
(function(){
  const canvas = document.getElementById('snow-canvas');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const CONFIG = {
    density: 0.11,
    globalSpeed: 1.0,
    windOscAmp: 0.55,
    windOscSpeed: 0.06,
    perParticleSway: 0.35,
    maxDrift: 0.35,
    fadeIn: true
  };
  const LAYERS = [
    { name:'far',  size:[0.6,1.4], speedY:[14,24], alpha:[0.15,0.35], blur:0,   countRatio:0.40 },
    { name:'mid',  size:[1.0,2.2], speedY:[22,38], alpha:[0.22,0.55], blur:0.5, countRatio:0.38 },
    { name:'near', size:[1.8,3.4], speedY:[34,58], alpha:[0.30,0.75], blur:0.9, countRatio:0.22 }
  ];
  let W=0,H=0, particles=[];
  let lastTime = performance.now();
  let windBase = 0;
  function rand(a,b){ return Math.random()*(b-a)+a; }
  function resize(){
    W = canvas.width  = canvas.offsetWidth  = canvas.parentElement.offsetWidth;
    H = canvas.height = canvas.offsetHeight = canvas.parentElement.offsetHeight;
    buildParticles();
  }
  window.addEventListener('resize', throttle(resize,250));
  resize();
  function totalCount(){ return Math.round((W*H/1000) * CONFIG.density); }
  function buildParticles(){
    particles.length = 0;
    const total = totalCount();
    LAYERS.forEach(layer=>{
      const need = Math.round(total * layer.countRatio);
      for(let i=0;i<need;i++){
        particles.push(makeParticle(layer, Math.random()*W, Math.random()*H));
      }
    });
  }
  function makeParticle(layer,x,y){
    const speedY = rand(layer.speedY[0], layer.speedY[1]) / 60 * CONFIG.globalSpeed;
    const r = rand(layer.size[0], layer.size[1]);
    return {
      layer,x,y,r,
      baseVy: speedY,
      alpha: rand(layer.alpha[0], layer.alpha[1]),
      swayOffset: Math.random()*Math.PI*2,
      swaySpeed: rand(0.4,1.1),
      driftSeed: Math.random()*1000,
      life:0,
      blur:layer.blur
    };
  }
  function update(dt){
    windBase += CONFIG.windOscSpeed * dt;
    const globalWind = Math.sin(windBase) * CONFIG.windOscAmp;
    for(let p of particles){
      p.life += dt;
      const sway = Math.sin(p.swayOffset + p.life * p.swaySpeed) * CONFIG.perParticleSway;
      const drift = (Math.sin((p.driftSeed + p.life*30)*0.015)+Math.sin((p.driftSeed + p.life*55)*0.011))*0.5*CONFIG.maxDrift;
      p.x += (globalWind + sway + drift) * (0.6 + (p.r*0.12));
      p.y += p.baseVy * dt * 60;
      if(p.x > W+8) p.x = -8;
      else if(p.x < -8) p.x = W+8;
      if(p.y > H+10){
        p.x = Math.random()*W;
        p.y = rand(-40,-10);
        p.life = 0;
        p.baseVy = rand(p.layer.speedY[0], p.layer.speedY[1]) / 60 * CONFIG.globalSpeed;
        p.r = rand(p.layer.size[0], p.layer.size[1]);
        p.alpha = rand(p.layer.alpha[0], p.layer.alpha[1]);
      }
    }
  }
  function draw(){
    ctx.clearRect(0,0,W,H);
    for(let layer of LAYERS){
      ctx.save();
      for(let p of particles){
        if(p.layer !== layer) continue;
        const a = CONFIG.fadeIn ? Math.min(p.alpha, p.alpha*(p.life*0.6)) : p.alpha;
        ctx.globalAlpha = a;
        if(p.blur>0){
          ctx.shadowBlur = p.blur*8;
          ctx.shadowColor = 'rgba(255,255,255,'+a+')';
        } else ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.fillStyle = '#fff';
        ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }
  }
  function loop(now){
    const dt = Math.min(0.07, (now - lastTime)/1000);
    lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  function throttle(fn, ms){
    let t=0;
    return function(...args){
      if(performance.now()-t>ms){ t=performance.now(); fn.apply(this,args); }
    };
  }
})();
</script>
<script>
// ==== FIND MODAL (Word-like) ====
let findMatches = [];
let currentFindIndex = -1;
let lastFindQuery = '';
let findObserver = null;

function openFindModal(){
  const b = document.getElementById('find-backdrop');
  if(!b) return;
  b.style.display='flex';
  const inp = document.getElementById('find-query');
  setTimeout(()=>inp.focus(),30);
  if(lastFindQuery){ inp.value = lastFindQuery; performFind(lastFindQuery); }
}
function closeFindModal(){
  const b = document.getElementById('find-backdrop');
  if(b) b.style.display='none';
  clearFindHighlights();
}
document.addEventListener('keydown', e=>{
  if(e.key==='Escape'){
    const b=document.getElementById('find-backdrop');
    if(b && b.style.display!=='none'){ closeFindModal(); }
  }
});

function performFind(q){
  lastFindQuery = q;
  clearFindHighlights(true);
  if(!q){
    updateFindCount();
    return;
  }
  const caseSensitive = document.getElementById('find-case')?.checked;
  let re;
  try { re = new RegExp(escapeRegExp(q), caseSensitive?'g':'gi'); } catch(_){ return; }
  const container = document.getElementById('chat-messages');
  if(!container) return;

  const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, {
    acceptNode: n=>{
      if(!n.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
      if(n.parentElement && n.parentElement.classList.contains('find-highlight')) return NodeFilter.FILTER_REJECT;
      return NodeFilter.FILTER_ACCEPT;
    }
  });
  const nodes=[];
  while(walker.nextNode()) nodes.push(walker.currentNode);

  nodes.forEach(node=>{
    const txt = node.nodeValue;
    let m,last=0,frag=document.createDocumentFragment(),found=false;
    re.lastIndex=0;
    while((m = re.exec(txt))!==null){
      found=true;
      const pre = txt.slice(last,m.index);
      if(pre) frag.appendChild(document.createTextNode(pre));
      const span = document.createElement('span');
      span.className='find-highlight';
      span.textContent=m[0];
      frag.appendChild(span);
      findMatches.push(span);
      last = m.index + m[0].length;
      if(m[0].length===0) re.lastIndex++;
    }
    if(found){
      const rest = txt.slice(last);
      if(rest) frag.appendChild(document.createTextNode(rest));
      node.parentNode.replaceChild(frag,node);
    }
  });

  currentFindIndex = findMatches.length?0:-1;
  activateCurrentMatch();
  updateFindCount();

  if(findObserver) findObserver.disconnect();
  if(q){
    findObserver = new MutationObserver(()=>{
      const qq = lastFindQuery;
      if(qq) performFind(qq);
    });
    findObserver.observe(container,{childList:true,subtree:true});
  }
}

function findNext(){
  if(!findMatches.length){
    performFind(document.getElementById('find-query').value.trim());
    return;
  }
  currentFindIndex = (currentFindIndex+1) % findMatches.length;
  activateCurrentMatch();
  updateFindCount();
}
function findPrev(){
  if(!findMatches.length){
    performFind(document.getElementById('find-query').value.trim());
    return;
  }
  currentFindIndex = (currentFindIndex-1 + findMatches.length) % findMatches.length;
  activateCurrentMatch();
  updateFindCount();
}

function activateCurrentMatch(){
  findMatches.forEach(s=>s.classList.remove('active'));
  if(currentFindIndex>=0 && findMatches[currentFindIndex]){
    const el = findMatches[currentFindIndex];
    el.classList.add('active');
    const container = document.getElementById('chat-messages');
    const rect = el.getBoundingClientRect();
    const cRect = container.getBoundingClientRect();
    const scrollTo = rect.top - cRect.top + container.scrollTop - (container.clientHeight/2) + rect.height/2;
    container.scrollTo({ top: scrollTo, behavior:'smooth' });
  }
}

function updateFindCount(){
  const el = document.getElementById('find-count');
  if(!el) return;
  if(!findMatches.length) el.textContent='0 / 0';
  else el.textContent=(currentFindIndex+1)+' / '+findMatches.length;
}

function clearFindHighlights(keepObs){
  if(findObserver && !keepObs){ findObserver.disconnect(); findObserver=null; }
  if(!findMatches.length) return;
  findMatches.forEach(span=>{
    if(span.parentNode){
      span.parentNode.replaceChild(document.createTextNode(span.textContent), span);
    }
  });
  findMatches=[];
  currentFindIndex=-1;
  updateFindCount();
}

function escapeRegExp(str){ return str.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }

document.addEventListener('DOMContentLoaded', ()=>{
  const q=document.getElementById('find-query');
  if(q){
    q.addEventListener('input', e=>performFind(e.target.value.trim()));
    q.addEventListener('keydown', e=>{
      if(e.key==='Enter'){
        e.preventDefault();
        if(e.shiftKey) findPrev(); else findNext();
      }
    });
  }
  const c=document.getElementById('find-case');
  if(c){ c.addEventListener('change', ()=>performFind(q.value.trim())); }
});
</script>

<!-- KaTeX helper & auto-render (Doctor-style) -->
<script>
(function(){
  if (window._jaremis_shortcuts_installed) return; window._jaremis_shortcuts_installed = true;

  // Safe helper to click an element by id
  function tryClick(id){ try{ const el = document.getElementById(id); if(el){ el.click(); return true; } }catch(e){} return false; }

  // Provide lightweight global stubs (will defer to real implementations when available)
  window.jaremis = window.jaremis || {};
  window.jaremis.ensureRenderMath = function(el){ if (window.renderMathIn) return window.renderMathIn(el); /* no-op until katex loader runs */ };
  // Keep existing wrapResultMath/addResultBoxStyles if present; otherwise noop
  if (!window.wrapResultMath) window.wrapResultMath = function(b){ /* will be replaced by real implementation if defined later */ };
  if (!window.addResultBoxStyles) window.addResultBoxStyles = function(){ };

  // Keyboard shortcuts mapping (use Ctrl+letter / Ctrl+Shift+letter). Avoid overriding basic input behavior.
  document.addEventListener('keydown', function(e){
    const tgt = e.target || {};
    const tag = (tgt.tagName || '').toUpperCase();
    const isEditable = tag === 'INPUT' || tag === 'TEXTAREA' || tgt.isContentEditable;

    // Ctrl+Enter -> send (works even when typing)
    if (e.ctrlKey && !e.shiftKey && e.key === 'Enter') {
      e.preventDefault(); tryClick('send-btn'); return;
    }

    // If typing in a text field, do not hijack other shortcuts (except send)
    if (isEditable) return;

    // Map single Ctrl+letter and Ctrl+Shift+letter combinations
    if (e.ctrlKey && !e.altKey) {
      const k = (e.key || '').toLowerCase();
      const shift = e.shiftKey;
      // Mic: Ctrl+M
      if (!shift && k === 'm') { e.preventDefault(); tryClick('mic-btn'); flashNotice && flashNotice('Mic toggled (Ctrl+M)'); return; }
      // Attach: Ctrl+Shift+U
      if (shift && k === 'u') { e.preventDefault(); tryClick('attach-btn') || document.getElementById('images')?.click(); flashNotice && flashNotice('Attach file (Ctrl+Shift+U)'); return; }
      // Diagnose: Ctrl+Shift+K
      if (shift && k === 'k') { e.preventDefault(); tryClick('mode-btn'); flashNotice && flashNotice('Toggle Diagnose (Ctrl+Shift+K)'); return; }
      // Model switch: Ctrl+Shift+Y
      if (shift && k === 'y') { e.preventDefault(); tryClick('think-btn'); flashNotice && flashNotice('Switch model (Ctrl+Shift+Y)'); return; }
      // New chat: Ctrl+Shift+X
      if (shift && k === 'x') { e.preventDefault(); startNewConversation && startNewConversation(); flashNotice && flashNotice('New chat (Ctrl+Shift+X)'); return; }
      // Open history/find: Ctrl+Shift+F
      if (shift && k === 'f') { e.preventDefault(); openFindModal && openFindModal(); flashNotice && flashNotice('Find (Ctrl+Shift+F)'); return; }
    }
  }, true);

  // Ensure chatInput Ctrl+Enter works even if focus is inside textarea
  try { const ci = document.getElementById('chat-input'); const sb = document.getElementById('send-btn');
    if (ci && sb) {
      ci.addEventListener('keydown', function(ev){ if (ev.ctrlKey && ev.key === 'Enter') { ev.preventDefault(); sb.click(); } });
    }
  } catch(e){}

})();
</script>
<!-- KaTeX helper & auto-render (Doctor-style) -->
<script>
// Define helper like Doctor's implementation and an unobtrusive observer
if (!window._jaremis_katex_setup) {
  window._jaremis_katex_setup = true;

  // renderMathIn wrapper (safe: no throw, ignores code/pre)
  function renderMathIn(el){
    if (!el || !window.renderMathInElement) return;
    try{
      window.renderMathInElement(el, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$',  right: '$',  display: false},
          {left: '\\[', right: '\\]', display: true},
          {left: '\\(', right: '\\)', display: false}
        ],
        throwOnError: false,
        ignoredTags: ['script','noscript','style','textarea','pre','code'],
        ignoredClasses: ['no-math','katex']
      });
    }catch(err){
      // don't interfere with app; just warn
      console.warn('renderMathIn error', err);
    }
  }

  window.renderMathIn = renderMathIn;

  // Normalize LaTeX delimiters inside text nodes of an element.
  function normalizeLatexInElement(el){
    if(!el) return;
    try{
      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
      const nodes = [];
      while(walker.nextNode()) nodes.push(walker.currentNode);
      nodes.forEach(n => {
        let s = n.nodeValue;
        if(!s || (!s.includes('$') && !s.includes('\\(') && !s.includes('\\['))) return;
        // Collapse repeated dollar signs (e.g. $$$ -> $$)
        s = s.replace(/\${3,}/g, '$$');
        // Convert display $$...$$ to \[ ... \]
        s = s.replace(/\$\$(.*?)\$\$/gs, '\\[$1\\]');
        // Convert simple inline $...$ to \\( ... \\)
        // Avoid replacing when $ is adjacent to whitespace at boundaries
        s = s.replace(/\$(\S[\s\S]*?\S)\$/gs, '\\\($1\\\)');
        // Trim accidental spaces inside delimiters
        s = s.replace(/\\\(\s+/g,'\\\\(').replace(/\s+\\\)/g,'\\\\)');
        n.nodeValue = s;
      });
    }catch(err){ console.warn('normalizeLatexInElement error', err); }
  }

  function cleanupStrayDollarSigns(el){
    if(!el) return;
    try{
      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
      const nodes = [];
      while(walker.nextNode()) nodes.push(walker.currentNode);
      for(const n of nodes){
        // skip text nodes that are inside a KaTeX-rendered element
        if(n.parentElement && n.parentElement.closest && n.parentElement.closest('.katex')) continue;
        let s = n.nodeValue;
        if(!s || !s.includes('$')) continue;
        // Remove unescaped single or double dollar signs left over (keep escaped \$)
        // Use lookbehind to avoid removing \$
        try{
          s = s.replace(/(?<!\\)\${1,2}/g, '');
        }catch(e){
          // fallback for older engines: remove all $ then restore escaped sequences
          s = s.replace(/\\\$/g, '__ESC_DOLLAR__').replace(/\$/g,'').replace(/__ESC_DOLLAR__/g,'\\$');
        }
        n.nodeValue = s;
      }
    }catch(err){ console.warn('cleanupStrayDollarSigns error', err); }
  }

  function renderBubbleIfNeeded(bubble){
    if (!bubble || bubble.dataset.katexRendered) return;
    if (!bubble.classList || !bubble.classList.contains('chat-bubble')) return;
    // Normalize delimiters first to avoid stray $ and inconsistent markers
    normalizeLatexInElement(bubble);
    renderMathIn(bubble);
    // Remove any leftover $ or $$ in plain text nodes outside KaTeX elements
    cleanupStrayDollarSigns(bubble);
    bubble.dataset.katexRendered = '1';
  }

  // Auto-render existing chat bubbles and newly added ones.
  document.addEventListener('DOMContentLoaded', ()=>{
    const container = document.getElementById('chat-messages');
    if (!container) return;
    // Render existing bubbles
    container.querySelectorAll('.chat-bubble').forEach(renderBubbleIfNeeded);
    // Observe added nodes
    const mo = new MutationObserver(muts=>{
      for (const m of muts){
        for (const n of m.addedNodes){
          if (n.nodeType !== 1) continue;
          if (n.classList && n.classList.contains('chat-bubble')) renderBubbleIfNeeded(n);
          else if (n.querySelectorAll) n.querySelectorAll('.chat-bubble').forEach(renderBubbleIfNeeded);
        }
      }
    });
    mo.observe(container, { childList: true, subtree: true });
  });
}
</script>
</body>
</html>