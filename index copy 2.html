<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>JAREMIS - AI Chat</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
    <style>
        :root {
            --sidebar-width: 260px;
            --bg-color: #0d1117;
            --sidebar-bg: #161b22;
            --chat-bg: #010409;
            --input-bg: #161b22;
            --bot-bubble-bg: #161b22;
            --user-bubble-bg: #003666;
            --text-color: #c9d1d9;
            --text-secondary-color: #8b949e;
            --border-color: #30363d;
            --accent-color: #2f81f7;
            --error-color: #f85149;
            --success-color: #238636;
            --who-bg: #212013;
            --mic-red: #ff4d4d;

            --auth-offset-top: 12px;
            --auth-offset-height: 48px; /* chiều cao ước lượng vùng auth (để chừa khoảng trống) */
            --mobile-header-height: 56px; /* chiều cao header mobile (nếu hiện) */
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Hide mobile-only toggles on desktop */
        .mobile-header { display: none; }
        #history-drawer-toggle { display: none; }

        .chat-container { display: flex; width: 100%; height: 100%; }

        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            min-width: 200px;
            max-width: 500px;
            background-color: var(--sidebar-bg);
            display: flex;
            flex-direction: column;
            padding: 16px;
            transition: width 0.1s ease-out;
            flex-shrink: 0;
        }
        .resizer { width: 5px; cursor: col-resize; background-color: transparent; flex-shrink: 0; position: relative; z-index: 10; }
        .resizer:hover { background-color: var(--accent-color); }

        .sidebar-header {
          display:flex;
          flex-direction:column;
          align-items:stretch;
          gap:8px;
          margin-bottom:12px;
        }

        .new-chat-btn {
            display:flex; align-items:center; gap:8px; width:100%; padding:10px; background:transparent; color:var(--text-color);
            border:1px solid var(--border-color); border-radius:6px; font-size:14px; cursor:pointer;
        }
        .new-chat-btn:hover { background-color:#2c313a; }

        .history { flex-grow:1; overflow-y:auto; margin-top:10px; }
        .history h3 { font-size:12px; color:var(--text-secondary-color); margin-bottom:8px; text-transform:uppercase; display:flex; justify-content:space-between; align-items:center; }
        .history ul { list-style:none; padding:0; display:flex; flex-direction:column; gap:6px; }
        .history li { padding:8px; border-radius:6px; cursor:pointer; color:var(--text-color); background:transparent; border:1px solid transparent; font-size:13px; }
        .history li:hover { background:#111720; border-color:var(--border-color); }
        .sidebar-footer { font-size:12px; color:var(--text-secondary-color); text-align:center; margin-top:10px; }

        /* Chat area */
        .chat-area {
            position: relative; /* Đảm bảo lớp nền phủ đúng */
            flex-grow:1; display:flex; flex-direction:column; background-color:var(--chat-bg); border-left:1px solid var(--border-color); /* position:relative; */
        }
        .chat-messages {
          flex-grow:1;
          padding:24px;
          overflow-y:auto;
          display:flex;
          flex-direction:column;
          gap:20px;
          background: transparent;          /* đảm bảo không che nền */
          scrollbar-color: var(--accent-color) transparent; /* Firefox */
          scrollbar-width: thin;
        }

        /* Scrollbar WebKit (Chrome / Edge) */
        .chat-messages::-webkit-scrollbar {
          width: 10px;
        }
        .chat-messages::-webkit-scrollbar-track {
          background: transparent;          /* trong suốt để lộ nền & canvas tuyết */
        }
        .chat-messages::-webkit-scrollbar-thumb {
          background: linear-gradient(180deg, rgba(47,129,247,0.55), rgba(47,129,247,0.25));
          border-radius: 20px;
          border: 2px solid rgba(0,0,0,0);  /* tạo khoảng cách thị giác */
          min-height: 40px;
          transition: background .25s;
        }
        .chat-messages::-webkit-scrollbar-thumb:hover {
          background: linear-gradient(180deg, rgba(47,129,247,0.85), rgba(47,129,247,0.45));
        }
        .chat-messages::-webkit-scrollbar-corner {
          background: transparent;
        }
        /* (Tuỳ chọn) Ẩn hẳn khi không hover:
        .chat-messages::-webkit-scrollbar { width: 0; }
        */

        .chat-bubble { max-width:80%; padding:16px; border-radius:12px; line-height:1.6; word-wrap:break-word; }
        .bot-bubble { background-color:var(--bot-bubble-bg); align-self:flex-start; border:1px solid var(--border-color); }
        .user-bubble { background-color:var(--user-bubble-bg); align-self:flex-end; color:#fff; }

        .user-bubble-content p { margin-bottom:12px; }
        .user-images-preview { display:flex; gap:10px; flex-wrap:wrap; }
        .user-images-preview img { width:80px; height:80px; object-fit:cover; border-radius:8px; border:1px solid var(--border-color); }

        .chat-input-area { padding:16px 24px; border-top:1px solid var(--border-color); display:flex; flex-direction:column; gap:8px; }
        .input-wrapper { position:relative; display:flex; align-items:center; background-color:var(--input-bg); border:1px solid var(--border-color); border-radius:8px; padding:8px; gap:8px; }

        #chat-input { flex-grow:1; background:transparent; border:none; color:var(--text-color); font-size:16px; padding:8px; resize:none; max-height:200px; overflow-y:auto; }
        #chat-input:focus { outline:none; }

        .input-actions { display:flex; align-items:center; gap:8px; }
        .action-btn {
            background:none; border:none; color:var(--text-secondary-color); font-size:20px; cursor:pointer; width:40px; height:40px; border-radius:6px;
            display:flex; align-items:center; justify-content:center;
        }
        .action-btn:hover { background-color:#2c313a; color:var(--text-color); }
        #send-btn { background-color:var(--accent-color); color:white; border-radius:6px; width:44px; height:40px; display:flex; align-items:center; justify-content:center; }
        #send-btn:disabled { background-color:#30363d; cursor:not-allowed; }

        #image-preview-container { display:flex; gap:10px; margin-top:10px; padding:0 8px; }
        .preview-item { position:relative; }
        .preview-item img { width:60px; height:60px; object-fit:cover; border-radius:6px; }
        .remove-btn { position:absolute; top:-5px; right:-5px; background:var(--error-color); color:white; border:none; width:20px; height:20px; border-radius:50%; cursor:pointer; font-size:12px; display:flex; align-items:center; justify-content:center; }

        /* Analysis steps */
        .analysis-steps { display:flex; flex-direction:column; gap:12px; }
        .step-item { display:flex; align-items:center; gap:12px; font-size:14px; transition:color 0.3s ease; }
        .step-item .icon { width:20px; text-align:center; }
        .step-item.pending { color:var(--text-secondary-color); }
        .step-item.active { color:var(--text-color); font-weight:600; }
        .step-item.completed { color:var(--success-color); }
        .fa-spinner { animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform:rotate(0deg); } 100% { transform:rotate(360deg); } }

        /* Result */
        .error-message { color:var(--error-color); }
        .confidence-meter { background:#2c313a; border-radius:20px; height:24px; margin:16px 0; overflow:hidden; position:relative; }
        .confidence-bar { background:var(--success-color); height:100%; display:flex; align-items:center; padding-left:12px; color:white; font-weight:bold; font-size:12px; transition: width 0.5s ease; }

        .disease-list { margin:20px 0; display:flex; flex-direction:column; gap:15px; }
        .disease-item { border-left:3px solid var(--accent-color); padding-left:15px; }
        .probability-bar { height:8px; background:#30363d; border-radius:10px; overflow:hidden; margin-top:8px; }
        .probability-fill { height:100%; background:var(--accent-color); transition:width 0.5s ease; }

        .diagnosis-details h2, .diagnosis-details h3 { border-bottom:1px solid var(--border-color); padding-bottom:8px; margin:20px 0 10px 0; font-size:1.1em; }
        .references-section { margin-top:25px; padding:15px; background:rgba(47,129,247,0.1); border-radius:8px; }
        .reference-item { margin-top:10px; }
        .reference-item a { color:var(--accent-color); text-decoration:none; }
        .reference-item a:hover { text-decoration:underline; }
        .reference-source { font-size:0.8em; color:var(--text-secondary-color); margin-top:4px; }

        .warning { margin-top:20px; padding:12px; background:var(--who-bg); border-left:4px solid #f1e05a; color:#d4c873; font-size:14px; border-radius:4px; }
        .warning strong { color:#f1e05a; }

        /* Think button style */
        #think-btn { background:none; border:1px solid var(--border-color); border-radius:6px; padding:6px 8px; color:var(--text-secondary-color); cursor:pointer; width:auto; height:40px; display:flex; align-items:center; justify-content:center; }
        #think-btn.active { background: linear-gradient(90deg, rgba(47,129,247,0.12), rgba(47,129,247,0.06)); color:var(--text-color); border-color: rgba(47,129,247,0.6); }
        #model-status { font-size:12px; color:var(--text-secondary-color); margin-left:8px; align-self:center; }

        /* Mic button style */
        #mic-btn { background:none; border:1px solid var(--border-color); border-radius:6px; padding:6px 8px; color:var(--text-secondary-color); cursor:pointer; width:auto; height:40px; display:flex; align-items:center; justify-content:center; }
        #mic-btn.recording { background: rgba(255,77,77,0.12); color: var(--text-color); border-color: rgba(255,77,77,0.5); box-shadow: 0 0 8px rgba(255,77,77,0.12); }
        #mic-indicator {
            width:8px; height:8px; border-radius:50%; background:var(--mic-red); margin-left:6px; display:inline-block; opacity:0;
            box-shadow: 0 0 6px rgba(255,77,77,0.8);
            animation: pulse 1.2s infinite;
        }
        #mic-btn.recording #mic-indicator { opacity:1; }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.5); opacity: 0.5; }
            100% { transform: scale(1); opacity: 0.9; }
        }

        /* Auth UI (top-right) */
        .auth-controls {
            position: fixed !important;
            top: var(--auth-offset-top) !important;
            right: 18px !important;
            bottom: auto !important;
            display: flex;
            gap: 8px;
            align-items: center;
            z-index: 120; /* cao hơn header & bong bóng */
            flex-direction: row !important;
        }
        @media (max-width:600px) {
            .auth-controls { right: 10px; }
        }

        /* Modal */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 60;
        }
        .modal {
            background: #0b1116;
            border: 1px solid var(--border-color);
            padding: 18px;
            border-radius: 10px;
            width: 360px;
            max-width: 92%;
            color: var(--text-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
        }
        .modal h3 { margin-bottom: 10px; font-size: 18px; }
        .tabs { display:flex; gap:8px; margin-bottom:12px; }
        .tab { padding:8px 12px; border-radius:6px; cursor:pointer; background:transparent; color:var(--text-secondary-color); border:1px solid transparent; }
        .tab.active { background: rgba(47,129,247,0.12); color:var(--text-color); border-color: rgba(47,129,247,0.2); }
        .form-row { margin-bottom:10px; display:flex; flex-direction:column; gap:6px; }
        .form-row input { background: #071018; border: 1px solid var(--border-color); color: var(--text-color); padding:8px 10px; border-radius:6px; }
        .form-actions { display:flex; justify-content:space-between; align-items:center; gap:8px; margin-top:8px; }
        .btn-primary { background: var(--accent-color); color: #fff; padding:8px 12px; border-radius:6px; border:none; cursor:pointer; }
        .btn-ghost { background:transparent; color:var(--text-secondary-color); border:1px solid var(--border-color); padding:8px 10px; border-radius:6px; cursor:pointer; }

        .small-muted { font-size:12px; color:var(--text-secondary-color); margin-top:8px; }

        /* Base (desktop) – giữ hàng ngang cho tool buttons */
        .tool-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .toggle-tools-btn {
            display: none; /* Chỉ hiện trên mobile */
        }

        /* Auth buttons styling */
        .auth-controls .auth-btn {
            background: rgba(255,255,255,0.04);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 6px 10px;
            font-size: 13px;
            border-radius: 6px;
            cursor: pointer;
            line-height: 1.2;
            backdrop-filter: blur(4px);
            transition: background .18s, border-color .18s, color .18s;
        }
        .auth-controls .auth-btn:hover {
            background: rgba(47,129,247,0.16);
            border-color: var(--accent-color);
            color: #fff;
        }
        .auth-controls .auth-btn:active {
            background: rgba(47,129,247,0.28);
        }

        /* small responsive */
        @media (max-width: 900px) {
            .sidebar { display:none; }
            .resizer { display:none; }
            .auth-controls { right: 8px; top: 8px; }
        }

        /* Mobile-specific overrides */
        @media (max-width: 600px) {
            /* layout becomes column for small screens */
            .chat-container { flex-direction:column; }
            .mobile-header { display:flex; align-items:center; gap:10px; padding:8px 10px; border-bottom:1px solid var(--border-color); background:var(--chat-bg); position:sticky; top:0; z-index:70; }
            .mobile-header .title { color:var(--text-color); font-weight:600; font-size:16px; flex:1; text-align:center; }
            .hamburger { background:transparent; border:1px solid var(--border-color); color:var(--text-secondary-color); width:44px; height:44px; border-radius:8px; display:inline-flex; align-items:center; justify-content:center; }
            /* Sidebar becomes overlay (hidden by default) */
            .sidebar { display:flex; position:fixed; top:0; left:0; bottom:0; width:78%; max-width:360px; transform:translateX(-120%); transition: transform 0.22s ease; z-index:80; box-shadow:6px 0 30px rgba(0,0,0,0.6); }
            .sidebar.mobile-open { transform:translateX(0); }
            .sidebar-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:75; display:none; }
            .sidebar-backdrop.show { display:block; }
            /* hide resizer (not needed) */
            .resizer { display:none; }
            /* Chat area sizing */
            .chat-area { flex:1 1 auto; min-height: calc(100vh - 56px); }
            .chat-messages { padding: 12px; padding-bottom:160px; overflow-y:auto; }
            /* Fix input to bottom and respect safe-area */
            .chat-input-area { position:fixed; left:0; right:0; bottom:env(safe-area-inset-bottom, 0); padding:8px 10px; background:linear-gradient(180deg, rgba(1,4,9,0.98), rgba(1,4,9,1)); z-index:70; border-top:1px solid var(--border-color); }
            .input-wrapper { padding:6px; gap:6px; }
            #chat-input { font-size:15px; padding:8px; max-height:120px; }
            .input-actions .action-btn { width:40px; height:40px; font-size:16px; }
            #send-btn { width:44px; height:40px; border-radius:8px; }
            /* Adjust auth controls so they don't overlap mobile input */
            .auth-controls { position:fixed; right:10px; bottom:110px; top:auto; z-index:69; display:flex; flex-direction:column; gap:8px; }
            /* Slightly reduce bubble max-width for narrow screens */
            .chat-bubble { max-width:94%; }
        }

        /* Even smaller devices: compact spacing & font sizes */
        @media (max-width: 420px) {
            .mobile-header { padding:6px 8px; }
            .mobile-header .title { font-size:14px; }
            .new-chat-btn span { display:none; } /* icon only to save space */
            .sidebar { width:84%; max-width:300px; }
            .chat-messages { padding:10px; padding-bottom:150px; gap:12px; }
            .input-actions .action-btn { width:38px; height:38px; font-size:15px; }
            #chat-input { font-size:14px; }
        }

        @media (max-width: 360px) {
            .mobile-header .title { font-size:13px; }
            .hamburger { width:40px; height:40px; }
            .auth-controls { right:8px; bottom:120px; }
            .chat-input-area { padding:8px; }
            .chat-messages { padding-bottom:140px; }
        }

        /* Compact tools (mobile) */
        @media (max-width:600px) {
            .input-wrapper {
                position: relative;
            }
            .toggle-tools-btn {
                display:flex !important;
            }
            .tool-buttons {
                display:flex;
                align-items:center;
                gap:6px;
                transition:opacity .18s ease, transform .18s ease;
            }
            .tool-buttons.collapsed {
                opacity:0;
                pointer-events:none;
                transform:translateY(4px);
                position:absolute;
                left:8px;
                right:60px;
                bottom:100%;
                /* hidden */
            }
            .mobile-tools-active .tool-buttons {
                opacity:1;
                transform:translateY(0);
                position:absolute;
                left:8px;
                right:60px;
                bottom:100%;
                background:rgba(22,27,34,0.95);
                padding:6px 8px;
                border:1px solid var(--border-color);
                border-radius:10px;
                box-shadow:0 4px 18px rgba(0,0,0,0.55);
                z-index:90;
            }
            .tool-buttons .action-btn {
                width:38px;
                height:38px;
                font-size:16px;
            }
            .toggle-tools-btn {
                display:flex;
                background:none;
                border:1px solid var(--border-color);
                width:40px;
                height:40px;
                border-radius:8px;
                align-items:center;
                justify-content:center;
                color:var(--text-secondary-color);
                cursor:pointer;
            }
            .toggle-tools-btn.active {
                background:rgba(47,129,247,0.15);
                color:var(--text-color);
                border-color:var(--accent-color);
            }
            /* Khi bàn phím mở (class keyboard-open gắn vào body) -> ép thu gọn */
            body.keyboard-open .tool-buttons:not(.force-open) {
                opacity:0;
                pointer-events:none;
                transform:translateY(4px);
            }
        }

        /* Nút toggle lịch sử trên mobile */
        #history-toggle-btn {
            display:none;
            background:transparent;
            border:1px solid var(--border-color);
            color:var(--text-secondary-color);
            padding:6px 10px;
            border-radius:8px;
            font-size:13px;
            cursor:pointer;
        }
        #history-toggle-btn.active {
            background:rgba(47,129,247,0.15);
            color:var(--text-color);
            border-color:var(--accent-color);
        }
        @media (max-width:600px) {
          #history-toggle-btn { display:inline-flex; align-items:center; gap:6px; }
        }

        /* Dual pane (landscape + đủ rộng) */
        @media (max-width:900px) and (orientation:landscape) and (min-width:640px) {
          body.dual-pane .sidebar {
              position:relative;
              transform:translateX(0) !important;
              width:230px;
              box-shadow:none;
          }
          body.dual-pane .sidebar-backdrop { display:none !important; }
          body.dual-pane .chat-area { min-height:100vh; }
          body.dual-pane #mobile-header { padding-right:0; }
          body.dual-pane #history-toggle-btn { display:none; }
        }
        /* Hiệu ứng vuốt (gợi ý) – chỉ chiều ngang */
        .sidebar {
           touch-action: pan-y;
        }

        @media (max-width:600px) {
          .history-drawer-toggle {
              position:fixed;
              top:50%;
              left:4px;
              transform:translateY(-50%);
              z-index:90;
              width:34px;
              height:52px;
              background:rgba(22,27,34,0.88);
              border:1px solid var(--border-color);
              border-left:none;
              border-radius:0 10px 10px 0;
              display:flex;
              align-items:center;
              justify-content:center;
              color:var(--text-secondary-color);
              cursor:pointer;
              backdrop-filter:blur(4px);
              transition:background .18s, color .18s;
          }
          .history-drawer-toggle:hover { background:rgba(47,129,247,0.15); color:var(--text-color); }
          .history-drawer-toggle.open { left: calc(78% - 18px); border-left:1px solid var(--border-color); border-radius:10px 0 0 10px; }
        }

        /* Phóng to nút history ≡ */
.history-top-toggle .history-icon,
.history-drawer-toggle .history-icon {
    font-size: 26px; /* tăng gấp ~2 lần so với font-awesome mặc định 14–16px */
    line-height: 1;
    display:inline-block;
    transform: translateY(-1px);
    letter-spacing:2px;
    font-weight:600;
}
.history-top-toggle,
.history-drawer-toggle {
    width:46px !important;
    height:46px !important;
}

/* Compact white triple bars button */
.history-top-toggle,
.history-drawer-toggle {
    background: var(--chat-bg) !important; /* trùng nền chính */
    border: 1px solid var(--border-color);
    box-shadow: 0 0 0 0 transparent;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:0;
}
.history-top-toggle:hover,
.history-drawer-toggle:hover {
    border-color: var(--accent-color);
    background: var(--chat-bg);
}
.history-top-toggle .bars,
.history-drawer-toggle .bars {
    display:flex;
    flex-direction:column;
    gap:5px;
    width:26px;
    height:22px;
    align-items:flex-start;
    justify-content:center;
}
.history-top-toggle .bar,
.history-drawer-toggle .bar {
    display:block;
    height:2px;              /* thon hơn */
    width:22px;
    background:#fff;          /* màu trắng */
    border-radius:2px;
    transition:width .25s ease, background .25s;
}
.history-top-toggle .bar:nth-child(2),
.history-drawer-toggle .bar:nth-child(2){
    width:18px;               /* giữa ngắn hơn nhẹ */
}
.history-top-toggle .bar:nth-child(3),
.history-drawer-toggle .bar:nth-child(3){
    width:14px;               /* dưới ngắn hơn nữa */
}
.history-top-toggle.open .bar,
.history-drawer-toggle.open .bar {
    background: var(--accent-color);
    width:22px;               /* khi mở đồng nhất chiều dài */
}
.history-top-toggle.open .bar:nth-child(2){
    width:22px;
}
.history-top-toggle.open .bar:nth-child(3){
    width:22px;
}
/* Ẩn style cũ của .history-icon nếu còn */
.history-icon { display:none !important; }

/* Override: loại viền trắng mờ nút history */
.history-top-toggle,
.history-drawer-toggle {
    border: 1px solid var(--chat-bg) !important; /* trùng nền -> coi như mất viền */
}

.history-top-toggle:hover,
.history-drawer-toggle:hover,
.history-top-toggle.open,
.history-drawer-toggle.open {
    border: 1px solid var(--border-color) !important; /* chỉ hiện viền khi hover / mở */
}

/* (Tuỳ chọn) nếu muốn bỏ hẳn viền luôn:
.history-top-toggle,
.history-drawer-toggle { border:0 !important; }
.history-top-toggle:hover,
.history-drawer-toggle:hover { border:0 !important; }
*/
/* Thêm ngay sau <body> */
.bg-animation {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 0; /* nằm dưới các chat bubble */
}
.particle {
    position: absolute;
    width: 4px; height: 4px;
    background: #8b5cf6;
    border-radius: 50%;
    animation: float 20s infinite linear;
    box-shadow: 0 0 10px #8b5cf6;
}
.particle:nth-child(1) { left: 20%; animation-delay: 0s; animation-duration: 15s; }
.particle:nth-child(2) { left: 40%; animation-delay: 5s; animation-duration: 20s; background: #7c3aed; box-shadow: 0 0 10px #7c3aed; }
.particle:nth-child(3) { left: 60%; animation-delay: 10s; animation-duration: 25s; background: #a78bfa; box-shadow: 0 0 10px #a78bfa; }
.particle:nth-child(4) { left: 80%; animation-delay: 15s; animation-duration: 18s; }
.particle:nth-child(5) { left: 10%; animation-delay: 8s; animation-duration: 22s; background: #7c3aed; box-shadow: 0 0 10px #7c3aed; }
@keyframes float {
    0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
}

/* Snowfall animation */
.particle.snowflake {
    border-radius: 50%;
    box-shadow: 0 0 8px #fff;
    position: absolute;
    animation: snow-fall linear infinite;
}
@keyframes snow-fall {
    0% { transform: translateY(-10vh); opacity: 0.8; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { transform: translateY(110vh); opacity: 0.2; }
}
#snow-canvas { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:0; }
.chat-messages, .chat-bubble { position:relative; z-index:2; } /* đảm bảo tuyết không đè lên */
    </style>
    <style>
      @media (max-width:600px) {
        /* Popup tool panel */
        #tool-buttons {
          position:absolute;
          bottom:100%;           /* nằm trên input */
          right:0;
          left:auto;
          display:flex;
          flex-direction:column; /* xếp dọc */
          gap:10px;
          padding:10px 12px;
          background:rgba(13,17,23,0.95);
          border:1px solid var(--border-color);
          border-radius:14px;
          box-shadow:0 8px 28px -4px rgba(0,0,0,0.55);
          backdrop-filter:blur(6px);
          transform-origin: bottom right;
          transition: opacity .18s ease, transform .18s ease;
          z-index:120;
          width:66px; /* đủ cho icon vuông */
        }
        /* Nếu muốn dạng 2 cột (bỏ comment):
        #tool-buttons {
           width:134px;
           flex-wrap:wrap;
           flex-direction:row;
        }
        #tool-buttons .action-btn { flex:0 0 calc(50% - 6px); }
        */

        #tool-buttons .action-btn {
          width:52px;
          height:52px;
          font-size:20px;
          border:1px solid var(--border-color);
          border-radius:12px;
          background:#161b22;
          transition:background .18s, border-color .18s, color .18s;
        }
        #tool-buttons .action-btn:hover {
          background:#1f2731;
          border-color:var(--accent-color);
          color:var(--text-color);
        }

        #tool-buttons.collapsed {
          opacity:0;
          transform:translateY(10px) scale(.92);
          pointer-events:none;
        }
        #tool-buttons:not(.collapsed) {
          opacity:1;
          transform:translateY(0) scale(1);
        }

        /* Căn nút + sát bên phải để panel mở lên ngay trên */
        .input-actions {
          position:relative;
        }
        #toggle-tools-btn {
          position:relative;
          z-index:121; /* nằm trên panel */
        }
      }
    </style>
    <style>
/* === 3D Tilt Effect (buttons) === */
.tilt-3d{
  position:relative;
  background:linear-gradient(145deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01));
  box-shadow:0 4px 10px -2px rgba(0,0,0,0.45), 0 0 0 1px var(--border-color);
  transform-style:preserve-3d;
  will-change:transform;
  transition:transform .28s cubic-bezier(.25,.8,.25,1), box-shadow .35s;
  border-radius:8px;
}
.tilt-3d:hover{
  box-shadow:
    0 6px 18px -4px rgba(0,0,0,0.55),
    0 0 0 1px rgba(47,129,247,0.55),
    0 0 14px -2px rgba(47,129,247,0.55);
}
.tilt-3d::after{
  content:'';
  position:absolute;
  inset:0;
  background:
    radial-gradient(circle at var(--mx,50%) var(--my,50%),
      rgba(255,255,255,0.28),
      rgba(255,255,255,0.05) 38%,
      rgba(255,255,255,0) 70%);
  opacity:var(--glow-o,0);
  mix-blend-mode:screen;
  pointer-events:none;
  transition:opacity .25s;
  border-radius:inherit;
}
.tilt-3d:active{
  transition:transform .08s;
  transform:perspective(800px) rotateX(0deg) rotateY(0deg) translateZ(0) scale(.95);
}
</style>
<!-- Ensure the drawer toggle appears on mobile only -->
<style>
  @media (max-width:600px){
    #history-drawer-toggle { display: inline-flex; }
    .mobile-header { display: flex; }
  }
</style>
</head>
<body>
    <div class="bg-animation">
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
    </div>
    <div class="chat-container">
        <!-- (XÓA nút cũ ở đây nếu còn) -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <button class="new-chat-btn" onclick="startNewConversation()" title="Cuộc trò chuyện mới (Ctrl+Shift+X)">
                    <i class="fas fa-plus"></i>
                    <span>Cuộc trò chuyện mới</span>
                </button>
                <button id="find-btn" class="new-chat-btn" onclick="openFindModal()" title="Tìm trong cuộc trò chuyện (Ctrl+Shift+F)">
                  <i class="fas fa-search"></i>
                  <span>Tìm kiếm</span>
                  <span style="margin-left:auto;font-size:11px;opacity:.6;">Ctrl+Shift+F</span>
                </button>
            </div>
            <nav class="history">
                <h3>
                    Lịch sử
                    <span id="history-actions" style="font-size:12px;"></span>
                </h3>
                <ul id="history-list"></ul>
            </nav>
            <div class="sidebar-footer">Made with ❤️ by TT1403 & Ant.</div>
        </aside>

        <div class="resizer" id="resizer"></div>
        <div class="sidebar-backdrop" id="sidebar-backdrop"></div>
 
         <main class="chat-area" id="chat-area">
            <canvas id="snow-canvas"></canvas>
            <!-- Nút toggle lịch sử mới (mobile) -->
            <button id="history-drawer-toggle" class="history-top-toggle" aria-label="Mở lịch sử">
                <span class="bars" aria-hidden="true">
                    <span class="bar"></span>
                    <span class="bar"></span>
                    <span class="bar"></span>
                </span>
            </button>
            <!-- Mobile header (shown on small screens) -->
            <div class="mobile-header" id="mobile-header">
                <button class="hamburger" id="mobile-menu-btn" aria-label="Mở menu"><i class="fas fa-bars"></i></button>
                <div class="title">JAREMIS</div>
                <button id="history-toggle-btn" aria-label="Xem lịch sử" onclick="toggleHistoryMode()">
                    <i class="fas fa-clock-rotate-left"></i><span style="margin-left:4px;">Lịch sử</span>
                </button>
            </div>
             <!-- Auth controls (top-right) -->
             <div class="auth-controls" id="auth-controls">
                 <!-- Will be populated by JS -->
             </div>
 
            <div class="chat-messages" id="chat-messages">
                <div style="height:12px;"></div> <!-- spacer tránh trùng nút auth -->
                <div class="chat-bubble bot-bubble">
                    <strong>Chào bạn 👋 Mình là JAREMIS.</strong>
                    <p style="margin-top:8px; color:var(--text-secondary-color);">
                        Hãy nhập các dấu hiệu, hỏi chuyện, hoặc bật chế độ <strong>Diagnose</strong> để yêu cầu chẩn đoán y khoa.
                    </p>
                </div>
            </div>

            <div class="chat-input-area">
                <div id="image-preview-container"></div>
                <div class="input-wrapper">
                    <textarea id="chat-input" placeholder="Nhập tin nhắn hoặc tải lên hình ảnh..." rows="1" oninput="autoResize(this)"></textarea>

                    <div class="input-actions">
                        <button id="toggle-tools-btn" class="toggle-tools-btn" title="Mở công cụ" onclick="toggleToolTray(event)">
                            <i class="fas fa-plus"></i>
                        </button>

                        <div id="tool-buttons" class="tool-buttons collapsed">
                            <button class="action-btn" id="attach-btn" onclick="document.getElementById('images').click()" title="Đính kèm ảnh (Ctrl+Shift+U)">
                                <i class="fas fa-paperclip"></i>
                            </button>
                            <button id="mode-btn" class="action-btn" title="Chế độ: Chat (Ctrl+Shift+K)" onclick="toggleMode(event)">
                                <i class="fas fa-comments"></i>
                            </button>
                            <button id="mic-btn" class="action-btn" title="Ghi giọng nói (Ctrl+M). Nhấn để bắt đầu/dừng" onclick="toggleMic(event)">
                                <i class="fas fa-microphone"></i>
                                <span id="mic-indicator"></span>
                            </button>
                            <button id="think-btn" class="action-btn" title="Bật Think (Ctrl+Shift+Y)" onclick="toggleThink(event)">
                                <i class="fas fa-brain"></i>
                            </button>
                        </div>

                        <button id="send-btn" class="action-btn" onclick="submitData()" title="Gửi (Enter)">
                            <i class="fas fa-paper-plane"></i>
                        </button>

                        <input type="file" id="images" multiple hidden onchange="handleImageUpload(event)">
                    </div>
                </div>

                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div id="model-status">Model: JAREMIS 1.5</div>
                    <div style="font-size:12px; color:var(--text-secondary-color);">Trạng thái: Rảnh</div>
                </div>
            </div>
        </main>
    </div>

    <!-- Auth modal -->
    <div class="modal-backdrop" id="auth-backdrop">
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="auth-title">
            <h3 id="auth-title">Đăng nhập / Đăng ký</h3>

            <div class="tabs">
                <div class="tab active" id="tab-login" onclick="showTab('login')">Đăng nhập</div>
                <div class="tab" id="tab-register" onclick="showTab('register')">Đăng ký</div>
            </div>

            <!-- Login form -->
            <div id="form-login">
                <div class="form-row">
                    <label>Username hoặc Email</label>
                    <input id="login-username" placeholder="Tên đăng nhập hoặc email">
                </div>
                <div class="form-row">
                    <label>Mật khẩu</label>
                    <input id="login-password" type="password" placeholder="Mật khẩu">
                </div>
                <div class="form-row">
                    <button class="btn-primary" onclick="submitLogin()">Đăng nhập</button>
                    <button class="btn-primary" onclick="loginWithGoogle()" style="background-color: #4285F4;"> <i class="fab fa-google"></i> Google</button>
                    <button class="btn-primary" onclick="loginWithFacebook()" style="background-color: #3b5998;"> <i class="fab fa-facebook"></i> Facebook</button>
                </div>

                <div class="form-actions">
                    <button class="btn-ghost" onclick="closeAuthModal()">Hủy</button>
                </div>
                <div class="small-muted">Bạn chưa có tài khoản? Chuyển sang tab "Đăng ký".</div>
            </div>

            <!-- Register form -->
            <div id="form-register" style="display:none">
                <div class="form-row">
                    <label>Tên đăng nhập</label>
                    <input id="reg-username" placeholder="Tên đăng nhập">
                </div>
                <div class="form-row">
                    <label>Email</label>
                    <input id="reg-email" placeholder="email@example.com" type="email">
                </div>
                <div class="form-row">
                    <label>Mật khẩu</label>
                    <input id="reg-password" type="password" placeholder="Mật khẩu (ít nhất 6 ký tự)">
                </div>

                <div class="form-actions">
                    <button class="btn-primary" onclick="submitRegister()">Đăng ký</button>
                    <button class="btn-ghost" onclick="closeAuthModal()">Hủy</button>
                </div>
                <div class="small-muted">Bằng cách đăng ký, bạn đồng ý thử nghiệm tính năng.</div>
            </div>
        </div>
    </div>

    <div class="modal-backdrop" id="find-backdrop" style="display:none;">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="find-title">
        <h3 id="find-title" style="display:flex;justify-content:space-between;align-items:center;">
          <span>Tìm kiếm</span>
          <button class="btn-ghost" style="padding:4px 10px;font-size:14px;" onclick="closeFindModal()" title="Đóng (Esc)">&times;</button>
        </h3>
        <div class="form-row" style="margin-bottom:10px;">
          <input id="find-query" placeholder="Nhập từ khóa... (Enter=Tiếp, Shift+Enter=Trước)" style="background:#071018;">
        </div>
        <div class="form-row" style="flex-direction:row;align-items:center;gap:14px;margin-bottom:12px;">
          <label style="display:flex;align-items:center;gap:6px;font-size:12px;">
            <input type="checkbox" id="find-case"> Phân biệt hoa/thường
          </label>
          <div id="find-count" style="margin-left:auto;font-size:12px;color:var(--text-secondary-color);">0 / 0</div>
        </div>
        <div class="form-actions" style="justify-content:flex-start;gap:8px;">
          <button class="btn-ghost" onclick="findPrev()" title="Trước (Shift+Enter)">Trước</button>
          <button class="btn-primary" onclick="findNext()" title="Tiếp (Enter)">Tiếp</button>
          <button class="btn-ghost" onclick="clearFindHighlights()" title="Xóa highlight">Xóa</button>
          <button class="btn-ghost" onclick="closeFindModal()" title="Đóng (Esc)">Đóng</button>
        </div>
        <div class="small-muted" style="margin-top:10px;">
          Ctrl+F mở • Enter=Tiếp • Shift+Enter=Trước • Esc=Đóng
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        // ------------------------------
        // UI elements & state
        // ------------------------------
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');
        const imageInput = document.getElementById('images');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const chatMessages = document.getElementById('chat-messages');
        const thinkBtn = document.getElementById('think-btn');
        const modelStatusEl = document.getElementById('model-status');
        const micBtn = document.getElementById('mic-btn');
        const micIndicator = document.getElementById('mic-indicator');
        const modeBtn = document.getElementById('mode-btn');

        const historyListEl = document.getElementById('history-list');
        const historyActionsEl = document.getElementById('history-actions');

        const authBackdrop = document.getElementById('auth-backdrop');
        const authControls = document.getElementById('auth-controls');

        let useProModel = false;
        let diagnosticMode = false; // Chat mode default
        let recognition = null;
        let isRecording = false;
        let textBeforeRecording = '';
        let historyCache = [];

        let currentSessionId = null;

        // Config: optional timeout cap for the 'flash' model. 0 disables auto-stop.
        // Set e.g. window.FLASH_TIMEOUT_MS = 45000 to cap at 45s.
        window.FLASH_TIMEOUT_MS = window.FLASH_TIMEOUT_MS ?? 0;

        // Helpers required by inline handlers and rendering
        function escapeHtml(str){
          if (str === null || str === undefined) return '';
          return String(str)
            .replace(/&/g,'&amp;')
            .replace(/</g,'&lt;')
            .replace(/>/g,'&gt;')
            .replace(/"/g,'&quot;')
            .replace(/'/g,'&#039;');
        }
        function autoResize(el){
          if(!el) return;
          el.style.height = 'auto';
          const maxH = 200;
          el.style.height = Math.min(maxH, el.scrollHeight || 0) + 'px';
        }

        // Mobile sidebar (hamburger) behavior: open/close existing sidebar overlay (no new elements)
        (function(){
          const mobileBtn = document.getElementById('mobile-menu-btn');
          const drawerToggleBtn = document.getElementById('history-drawer-toggle');
          const sidebarEl = document.getElementById('sidebar');
          const backdrop = document.getElementById('sidebar-backdrop');
          if (!sidebarEl || !backdrop) return;

          function openSidebar(){
            sidebarEl.classList.add('mobile-open');
            backdrop.style.display = 'block';
            backdrop.classList.add('show');
            document.body.classList.add('no-scroll');
            if (mobileBtn) mobileBtn.setAttribute('aria-expanded','true');
            if (drawerToggleBtn) drawerToggleBtn.classList.add('open');
            setTimeout(()=>{ try{ sidebarEl.focus(); }catch(e){} },50);
          }

          function closeSidebar(){
            sidebarEl.classList.remove('mobile-open');
            backdrop.classList.remove('show');
            backdrop.style.display = 'none';
            document.body.classList.remove('no-scroll');
            if (mobileBtn) mobileBtn.setAttribute('aria-expanded','false');
            if (drawerToggleBtn) drawerToggleBtn.classList.remove('open');
          }

          if (mobileBtn) {
            mobileBtn.addEventListener('click', function(e){
              e && e.preventDefault();
              if (sidebarEl.classList.contains('mobile-open')) closeSidebar();
              else openSidebar();
            });
          }

          if (drawerToggleBtn) {
            drawerToggleBtn.addEventListener('click', function(e){
              e && e.preventDefault();
              if (sidebarEl.classList.contains('mobile-open')) closeSidebar();
              else openSidebar();
            });
          }

          backdrop.addEventListener('click', function(){ closeSidebar(); });

          document.addEventListener('keydown', function(e){
            if (e.key === 'Escape' && sidebarEl.classList.contains('mobile-open')) closeSidebar();
          });

          if (historyListEl){
            historyListEl.addEventListener('click', function(e){
              const li = e.target.closest && e.target.closest('li');
              if (!li) return;
              setTimeout(closeSidebar, 120);
            });
          }

          function debounce(fn, ms){ let t; return function(){ clearTimeout(t); t = setTimeout(fn, ms); }; }
          window.addEventListener('resize', debounce(function(){ if (window.innerWidth > 600) closeSidebar(); }, 180));
        })();

        // ------------------------------
        function toggleMode(e) {
            e?.preventDefault();
            diagnosticMode = !diagnosticMode;
            if (diagnosticMode) {
                modeBtn.classList.add('active');
                modeBtn.title = 'Chế độ: Diagnose (chẩn đoán y khoa)';
                modeBtn.innerHTML = '<i class="fas fa-stethoscope"></i>';
            } else {
                modeBtn.classList.remove('active');
                modeBtn.title = 'Chế độ: Chat';
                modeBtn.innerHTML = '<i class="fas fa-comments"></i>';
            }
        }

        function toggleThink(e) {
            e?.preventDefault();
            useProModel = !useProModel;
            if (useProModel) {
                thinkBtn.classList.add('active');
                modelStatusEl.textContent = 'Model: JAREMIS PRO 1.5';
            } else {
                thinkBtn.classList.remove('active');
                modelStatusEl.textContent = 'Model: JAREMIS 1.5';
            }
        }

        // ------------------------------
        // Authentication & user state (client session stored in localStorage)
        // ------------------------------
        document.addEventListener('DOMContentLoaded', () => {
            renderAuthControls();
            const u = getLocalUser();
            if (u) fetchAndRenderHistory(u.username);
            // Restore anonymous session to keep context between page reloads
            try {
                const savedSess = localStorage.getItem('jaremis_session');
                if (savedSess) currentSessionId = savedSess;
            } catch(_) {}
        });

        function getLocalUser() {
            try {
                const raw = localStorage.getItem('jaremis_user');
                if (!raw) return null;
                return JSON.parse(raw);
            } catch (e) {
                return null;
            }
        }

        function renderAuthControls() {
            authControls.innerHTML = '';
            const user = getLocalUser();
            if (user) {
                const nameEl = document.createElement('div');
                nameEl.style.color = 'var(--text-color)';
                nameEl.style.fontSize = '13px';
                nameEl.textContent = user.username;

                const btnHistoryClear = document.createElement('button');
                btnHistoryClear.className = 'auth-btn';
                btnHistoryClear.textContent = 'Xóa lịch sử';
                btnHistoryClear.title = 'Xóa toàn bộ lịch sử chat';
                btnHistoryClear.onclick = async () => {
                    if (!confirm('Xóa toàn bộ lịch sử chat của bạn?')) return;
                    try {
                        const res = await fetch(`/api/history?username=${encodeURIComponent(user.username)}`, { method: 'DELETE' });
                        const json = await res.json();
                        if (!res.ok) {
                            alert(json.error || 'Không xóa được lịch sử');
                            return;
                        }
                        historyCache = [];
                        renderHistoryList([]);
                        flashNotice('Đã xóa lịch sử');
                    } catch (e) {
                        console.error(e);
                        flashNotice('Lỗi khi xóa lịch sử');
                    }
                };

                const logoutBtn = document.createElement('button');
                logoutBtn.className = 'auth-btn';
                logoutBtn.textContent = 'Đăng xuất';
                logoutBtn.onclick = () => {
                    try { localStorage.removeItem('jaremis_user'); } catch(e) {}
                    renderAuthControls();
                    historyCache = [];
                    renderHistoryList([]);
                };

                authControls.appendChild(nameEl);
                authControls.appendChild(btnHistoryClear);
                authControls.appendChild(logoutBtn);
            } else {
                const loginBtn = document.createElement('button');
                loginBtn.className = 'auth-btn';
                loginBtn.textContent = 'Đăng nhập';
                loginBtn.onclick = openAuthModal;

                const registerBtn = document.createElement('button');
                registerBtn.className = 'auth-btn';
                registerBtn.textContent = 'Đăng ký';
                registerBtn.onclick = () => { openAuthModal(); showTab('register'); };

                authControls.appendChild(loginBtn);
                authControls.appendChild(registerBtn);
            }
        }

        function openAuthModal() {
            authBackdrop.style.display = 'flex';
            showTab('login');
        }
        function closeAuthModal() {
            authBackdrop.style.display = 'none';
        }
        function showTab(tab) {
            document.getElementById('tab-login').classList.toggle('active', tab === 'login');
            document.getElementById('tab-register').classList.toggle('active', tab === 'register');
            document.getElementById('form-login').style.display = tab === 'login' ? 'block' : 'none';
            document.getElementById('form-register').style.display = tab === 'register' ? 'block' : 'none';
        }

        async function submitRegister() {
            const username = document.getElementById('reg-username').value.trim();
            const email = document.getElementById('reg-email').value.trim();
            const password = document.getElementById('reg-password').value;

            if (!username || !email || !password) {
                flashNotice('Vui lòng nhập đầy đủ thông tin đăng ký');
                return;
            }
            if (password.length < 6) {
                flashNotice('Mật khẩu ít nhất 6 ký tự');
                return;
            }

            try {
                const res = await fetch('/api/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, email, password })
                });
                const json = await res.json();
                if (!res.ok) {
                    flashNotice(json.error || 'Đăng ký thất bại');
                    return;
                }
                localStorage.setItem('jaremis_user', JSON.stringify(json.user));
                flashNotice('Đăng ký thành công! Bạn đã đăng nhập tạm thời.', 2000);
                closeAuthModal();
                renderAuthControls();
                fetchAndRenderHistory(json.user.username);
            } catch (e) {
                console.error('Register error', e);
                flashNotice('Lỗi kết nối khi đăng ký');
            }
        }

        async function submitLogin() {
            const usernameOrEmail = document.getElementById('login-username').value.trim();
            const password = document.getElementById('login-password').value;
            if (!usernameOrEmail || !password) {
                flashNotice('Vui lòng nhập username/email và mật khẩu');
                return;
            }
            try {
                const res = await fetch('/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ usernameOrEmail, password })
                });
                const json = await res.json();
                if (!res.ok) {
                    flashNotice(json.error || 'Đăng nhập thất bại');
                    return;
                }
                localStorage.setItem('jaremis_user', JSON.stringify(json.user));
                flashNotice('Đăng nhập thành công', 1200);
                closeAuthModal();
                renderAuthControls();
                fetchAndRenderHistory(json.user.username);
            } catch (e) {
                console.error('Login error', e);
                flashNotice('Lỗi kết nối khi đăng nhập');
            }
        }

        // New: Login with Google
        function loginWithGoogle() {
            window.location.href = '/auth/google';
        }

        // New: Login with Facebook
        function loginWithFacebook() {
            window.location.href = '/auth/facebook';
        }

        function flashNotice(msg, duration = 2000) {
            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble bot-bubble';
            bubble.innerHTML = `<em style="color:var(--text-secondary-color)">${escapeHtml(msg)}</em>`;
            chatMessages.appendChild(bubble);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            setTimeout(() => bubble.remove(), duration);
        }

        // ------------------------------
        // History: fetch, render, open
        // ------------------------------
        async function fetchAndRenderHistory(username) {
            if (!username) return;
            try {
                const res = await fetch(`/api/history?username=${encodeURIComponent(username)}`);
                const json = await res.json();
                if (!res.ok) {
                    console.warn('Không lấy được lịch sử', json);
                    renderHistoryList([]);
                    return;
                }
                historyCache = json.history || [];
                renderHistoryList(historyCache);
            } catch (e) {
                console.error('fetch history error', e);
            }
        }

        // Group & render history thành LIST CUỘC TRÒ CHUYỆN
        function renderHistoryList(list) {
          historyListEl.innerHTML = '';
          if (!list || list.length === 0) {
            historyListEl.innerHTML = `<li style="color:var(--text-secondary-color); font-size:13px;">Chưa có lịch sử</li>`;
            historyActionsEl.innerHTML = '';
            return;
          }
          // Gom theo sessionId
          const sessions = {};
          list.forEach(entry => {
            const sid = entry.sessionId || ('legacy-' + entry.id);
            if (!sessions[sid]) sessions[sid] = [];
            sessions[sid].push(entry);
          });
          // Sắp xếp session theo newest timestamp (lớn nhất)
          const sessionArray = Object.entries(sessions).map(([sid, entries]) => {
            const newestTs = Math.max(...entries.map(e => new Date(e.timestamp).getTime()));
            return { sid, entries, newestTs };
          }).sort((a,b) => b.newestTs - a.newestTs);

          sessionArray.forEach(sess => {
            // Lấy message user đầu tiên của session (cũ nhất type chat/diagnose có input)
            const chronological = [...sess.entries].sort((a,b)=> new Date(a.timestamp)-new Date(b.timestamp));
            const first = chronological.find(e => e.input && e.input.trim()) || chronological[chronological.length-1];
            const title = (first.input || 'Cuộc trò chuyện').slice(0,60) + (first.input && first.input.length>60 ? '...' : '');
            const timeLabel = new Date(sess.newestTs).toLocaleString();
            const li = document.createElement('li');
            li.dataset.session = sess.sid;
            li.innerHTML = `<div style="display:flex; flex-direction:column; gap:4px;">
                <div style="font-size:13px; color:var(--text-color); font-weight:600;">${escapeHtml(title)}</div>
                <div style="font-size:11px; color:var(--text-secondary-color);">${escapeHtml(timeLabel)} • ${sess.entries.length} lượt</div>
              </div>`;
            li.onclick = () => openConversation(sess.sid);
            historyListEl.appendChild(li);
          });
          historyActionsEl.innerHTML = ''; // bỏ nút cũ
        }

        // Mở toàn bộ cuộc trò chuyện
        function openConversation(sessionId) {
          const convoEntries = historyCache.filter(e => (e.sessionId || ('legacy-'+e.id)) === sessionId)
            .sort((a,b)=> new Date(a.timestamp)-new Date(b.timestamp));
          if (!convoEntries.length) return;
          chatMessages.innerHTML = '';
          convoEntries.forEach(entry => {
            // User bubble
            if (entry.input) {
              chatMessages.innerHTML += `<div class="chat-bubble user-bubble"><div class="user-bubble-content"><p>${escapeHtml(entry.input)}</p></div></div>`;
            }
            // Bot / kết quả
            if (entry.type === 'diagnose') {
              chatMessages.innerHTML += `<div class="chat-bubble bot-bubble">
                <div class="diagnosis-details">
                  <div style="font-size:12px; color:var(--text-secondary-color); margin-bottom:6px;">Diagnose • ${new Date(entry.timestamp).toLocaleString()}</div>
                  ${convertMarkdown(entry.diagnosis || '')}
                </div>
              </div>`;
            } else {
              chatMessages.innerHTML += `<div class="chat-bubble bot-bubble">
                <div class="diagnosis-details">
                  <div style="font-size:12px; color:var(--text-secondary-color); margin-bottom:6px;">Chat • ${new Date(entry.timestamp).toLocaleString()}</div>
                  ${convertMarkdown(entry.reply || '')}
                </div>
              </div>`;
            }
          });
          chatMessages.scrollTop = chatMessages.scrollHeight;
          currentSessionId = sessionId; // tiếp tục vào phiên này nếu người dùng muốn
          localStorage.setItem('jaremis_session', currentSessionId);
        }

        // ------------------------------
        // Mic / SpeechRecognition
        // ------------------------------
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition || null;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.lang = 'vi-VN';
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;
            recognition.continuous = false;

            recognition.onstart = () => {
                isRecording = true;
                micBtn.classList.add('recording');
                micBtn.title = 'Đang ghi âm — nhấn để dừng';
                textBeforeRecording = chatInput.value || '';
                chatInput.focus();
            };

            recognition.onerror = (event) => {
                console.warn('Speech recognition error', event.error);
                stopRecognition();
                flashNotice('Lỗi ghi âm: ' + (event.error || 'Không xác định'));
            };

            recognition.onend = () => {
                stopRecognition(false);
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';
                for (let i = 0; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript += transcript;
                    }
                }
                chatInput.value = (textBeforeRecording + ' ' + finalTranscript + interimTranscript).trim();
                autoResize(chatInput);
            };
        } else {
            micBtn.title = 'Trình duyệt của bạn không hỗ trợ ghi âm chuyển văn bản (Web Speech API). Dùng Chrome/Microsoft Edge mới nhất để có chức năng này.';
            micBtn.style.opacity = '0.6';
            micBtn.style.pointerEvents = 'none';
        }

        function toggleMic(e) {
            e?.preventDefault();
            if (!SpeechRecognition) return;
            if (!isRecording) startRecognition();
            else stopRecognition();
        }

        function startRecognition() {
            if (!recognition) return;
            try {
                textBeforeRecording = chatInput.value || '';
                recognition.start();
            } catch (err) {
                console.warn('Không thể bắt đầu ghi âm:', err);
                flashNotice('Không thể bắt đầu ghi âm: ' + (err.message || err));
            }
        }

        function stopRecognition(clearInterim = false) {
            if (!recognition) return;
            try { recognition.stop(); } catch (e) {}
            isRecording = false;
            micBtn.classList.remove('recording');
            micBtn.title = 'Ghi giọng nói (Vietnamese). Nhấn để bắt đầu/dừng';
            if (clearInterim) {
                chatInput.value = textBeforeRecording || '';
                autoResize(chatInput);
            }
        }

        // ------------------------------
        // Image preview
        // ------------------------------
        function handleImageUpload(event) {
            imagePreviewContainer.innerHTML = '';
            Array.from(event.target.files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = e => {
                    const div = document.createElement('div');
                    div.className = 'preview-item';
                    div.innerHTML = `
                        <img src="${e.target.result}" alt="Preview">
                        <button class="remove-btn" onclick="removeImage(${index})">&times;</button>
                    `;
                    imagePreviewContainer.appendChild(div);
                };
                reader.readAsDataURL(file);
            });
        }

        function removeImage(index) {
            const dt = new DataTransfer();
            const files = Array.from(imageInput.files);
            files.splice(index, 1);
            files.forEach(file => dt.items.add(file));
            imageInput.files = dt.files;
            handleImageUpload({ target: imageInput });
        }

        // ------------------------------
        // Animate analysis steps (UX)
        // ------------------------------
        async function animateAnalysisSteps(bubbleElement) {
            const steps = [
                'Đang khởi tạo và gửi dữ liệu...',
                'Tìm kiếm tài liệu tham khảo (PubMed, ClinicalTrials)...',
                'AI đang phân tích và chẩn đoán hình ảnh...',
                'Tổng hợp và định dạng kết quả chẩn đoán...'
            ];

            let html = '<div class="analysis-steps">';
            steps.forEach((step, index) => {
                html += `<div id="step-${index}" class="step-item pending">
                            <span class="icon"><i class="fas fa-hourglass-half"></i></span>
                            <span>${step}</span>
                         </div>`;
            });
            html += '</div>';
            bubbleElement.innerHTML = html;

            for (let i = 0; i < steps.length; i++) {
                const stepEl = bubbleElement.querySelector(`#step-${i}`);
                const iconEl = stepEl.querySelector('.icon');

                stepEl.classList.remove('pending');
                stepEl.classList.add('active');
                iconEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                await new Promise(resolve => setTimeout(resolve, 600 + Math.random() * 600));

                stepEl.classList.remove('active');
                stepEl.classList.add('completed');
                iconEl.innerHTML = '<i class="fas fa-check"></i>';
            }
        }

        // ------------------------------
        // Submit: chooses /api/chat or /api/diagnose
        // ------------------------------
        async function submitData() {
            // Prevent double-submit, but recover from stale/aborted controllers
            if (window._currentAbortController) {
                try {
                    const sig = window._currentAbortController.signal;
                    const startedAt = window._currentAbortStartedAt || 0;
                    const tooLong = Date.now() - startedAt > 20000; // 20s safety
                    if (sig && sig.aborted) {
                        window._currentAbortController = null;
                        window._currentAbortStartedAt = 0;
                    } else if (tooLong) {
                        // reset stuck state
                        try { window._currentAbortController.abort(); } catch(e) {}
                        window._currentAbortController = null;
                        window._currentAbortStartedAt = 0;
                    } else {
                        // still in-progress -> ignore new send
                        flashNotice && flashNotice('Đang xử lý phản hồi trước, hãy đợi hoặc nhấn nút dừng.');
                        return;
                    }
                } catch (e) {
                    window._currentAbortController = null;
                    window._currentAbortStartedAt = 0;
                }
            }
            const labResults = chatInput.value.trim();
            const images = imageInput.files;
            if (!labResults && images.length === 0) return;
            if (!currentSessionId) {
                currentSessionId = 'sess-' + Date.now();
                localStorage.setItem('jaremis_session', currentSessionId);
            }

            // Build user bubble
            let userHtml = `<div class="chat-bubble user-bubble"><div class="user-bubble-content">`;
            if (labResults) userHtml += `<p>${escapeHtml(labResults)}</p>`;
            if (images.length > 0) {
                let imagePreviews = '<div class="user-images-preview">';
                for (let i = 0; i < images.length; i++) {
                    imagePreviews += `<img src="${URL.createObjectURL(images[i])}" alt="user image">`;
                }
                imagePreviews += '</div>';
                userHtml += imagePreviews;
            }
            const currentUser = getLocalUser();
            if (currentUser) {
                userHtml += `<div style="margin-top:8px; font-size:12px; color:var(--text-secondary-color)">Đã gửi bởi: ${escapeHtml(currentUser.username)}</div>`;
            }
            userHtml += `</div></div>`;
            chatMessages.innerHTML += userHtml;

            // Clear input + previews
            chatInput.value = '';
            autoResize(chatInput);
            imagePreviewContainer.innerHTML = '';

            // Create loading bubble
            const loadingBubble = document.createElement('div');
            loadingBubble.className = 'chat-bubble bot-bubble';
            chatMessages.appendChild(loadingBubble);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            // Setup AbortController so user can stop the response
            const controller = new AbortController();
            window._currentAbortController = controller;
            window._currentAbortStartedAt = Date.now();

            // Toggle send button into stop button
            try {
                sendBtn.dataset.prevHtml = sendBtn.innerHTML || '';
                sendBtn.dataset.prevTitle = sendBtn.title || '';
                sendBtn.innerHTML = '<i class="fas fa-stop"></i>';
                sendBtn.title = 'Dừng AI (Ctrl+Enter)';
                sendBtn.onclick = function(e){ e?.preventDefault(); if (window._currentAbortController) window._currentAbortController.abort(); };
            } catch (e) {}

            // Implement 15s timeout for flash model
            let flashTimeoutId = null;
            const modelName = useProModel ? 'pro' : 'flash';
            const timeoutMs = (window.FLASH_TIMEOUT_MS ?? 0);
            if (modelName === 'flash' && timeoutMs > 0) {
                // stop if too slow
                flashTimeoutId = setTimeout(() => {
                    try {
                        if (window._currentAbortController) {
                            window._currentAbortController.abort();
                            flashNotice && flashNotice(`Flash model exceeded ${timeoutMs}ms timeout and was stopped.`);
                        }
                    } catch (e) { /* ignore */ }
                }, timeoutMs);
            }

            try {
                // Show thinking animation while the model is responding
                startThinking(loadingBubble);

                if (diagnosticMode) {
                    const formData = new FormData();
                    if (labResults) formData.append('labResults', labResults);
                    Array.from(images).forEach(img => formData.append('images', img));
                    formData.append('model', modelName);
                    formData.append('sessionId', currentSessionId);
                    if (currentUser) formData.append('submittedBy', currentUser.username);

                    const resp = await fetch('/api/diagnose', { method: 'POST', body: formData, signal: controller.signal });
                    if (!resp.ok) {
                        const error = await resp.json().catch(()=>({error:'Lỗi từ server'}));
                        throw new Error(error.error || 'Lỗi không xác định từ máy chủ');
                    }
                    const data = await resp.json();
                    // Prefer server-rendered KaTeX HTML to avoid client-side parsing issues
                    const html = data.diagnosisHtml;
                    stopThinking(loadingBubble);
                    if (html) {

                        loadingBubble.innerHTML = `<div class="bot-reply">${html}</div>`;
                        try {
                            if (window.jaremis && typeof window.jaremis.ensureRenderMath === 'function') {
                                window.jaremis.ensureRenderMath(loadingBubble);
                            } else if (typeof window.renderMathIn === 'function') {
                                window.renderMathIn(loadingBubble);
                            }
                        } catch(_) {}
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } else {
                        const fallback = convertMarkdown(data.diagnosis || '');
                        await renderBotReplyAnimated(loadingBubble, fallback);
                    }
                    if (currentUser) fetchAndRenderHistory(currentUser.username);
                } else {
                    // Use the new streaming endpoint for chat mode
                    await streamChatResponse(labResults, images, modelName, currentUser, currentSessionId, loadingBubble, controller.signal);
                }
           
           
            } catch (err) {
                if (err && err.name === 'AbortError') {
                    flashNotice('AI response stopped');
                    loadingBubble.remove();
                } else {
                    showError(err.message || String(err), loadingBubble);
                }
            } finally {
                // cleanup
                clearTimeout(flashTimeoutId);
                               window._currentAbortController = null;
                window._currentAbortStartedAt = 0;
                try {
                    sendBtn.innerHTML = sendBtn.dataset.prevHtml || '<i class="fas fa-paper-plane"></i>';
                    sendBtn.title = sendBtn.dataset.prevTitle || 'Gửi';
                    sendBtn.onclick = submitData;
                    delete sendBtn.dataset.prevHtml; delete sendBtn.dataset.prevTitle;
                } catch (e) {}
                imageInput.value = '';
            }
        }

        // New function to handle streaming chat responses
        async function streamChatResponse(message, images, model, user, sessionId, targetBubble, signal) {
            stopThinking(targetBubble); // Stop the "thinking..." animation
            targetBubble.innerHTML = ''; // Clear the bubble
            const container = document.createElement('div');
            container.className = 'bot-reply';
            targetBubble.appendChild(container);

            // Ensure request body matches backend expectations
            const body = { message, model, sessionId };
            if (user) body.submittedBy = user.username;
            if (images.length > 0) body.imagesCount = images.length;

            try {
                const response = await fetch('/api/chat-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                    signal: signal
                });

                // Improved error handling: parse backend error message
                if (!response.ok) {
                    const err = await response.json().catch(() => ({ error: 'Server error during streaming.' }));
                    let errorMsg = err.error || 'Failed to start stream.';
                    // Suggest common causes for streaming errors
                    errorMsg += '<br><span style="font-size:13px;color:var(--text-secondary-color)">Có thể do: API key hết hạn, thiếu key, vượt quota, hoặc server đang bảo trì.<br>Vui lòng kiểm tra lại cấu hình backend hoặc liên hệ hỗ trợ.</span>';
                    throw new Error(errorMsg);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullReply = '';
                let buffer = '';
                let finalReceived = false;
                let finalHtml = null;

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    
                    // Process buffer line by line for SSE messages
                    let boundary;
                    while ((boundary = buffer.indexOf('\n\n')) >= 0) {
                        const message = buffer.substring(0, boundary);
                        buffer = buffer.substring(boundary + 2);

                        if (message.startsWith('data: ')) {
                            try {
                                const jsonString = message.substring(6);
                                const data = JSON.parse(jsonString);
                                if (data.chunk) {
                                    fullReply += data.chunk;
                                    // During streaming, render as plain escaped text to avoid breaking LaTeX delimiters
                                    container.innerHTML = escapeHtml(fullReply).replace(/\n/g, '<br>');
                                    // Scroll to bottom as content is added
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                }
                                if (data.error) {
                                    container.innerHTML = `<div class="error-message">${escapeHtml(data.error)}</div>`;
                                    finalReceived = true;
                                }
                                if (data.done) {
                                    finalReceived = true;
                                    finalHtml = data.replyHtml || null;
                                }
                            } catch (e) {
                                console.error('Error parsing stream data:', e);
                            }
                        }
                    }
                }
                
                // Final render to catch any remaining buffer and apply KaTeX
                if (finalReceived && finalHtml) {
                    container.innerHTML = finalHtml;
                } else if (fullReply) {
                    container.innerHTML = marked.parse(fullReply);
                }
                if (window.jaremis && typeof window.jaremis.ensureRenderMath === 'function') {
                    window.jaremis.ensureRenderMath(targetBubble);
                } else if (typeof window.renderMathIn === 'function') {
                    window.renderMathIn(targetBubble);
                }
                chatMessages.scrollTop = chatMessages.scrollHeight;

                // Update history after the full response is received
                if (user) {
                    fetchAndRenderHistory(user.username);
                }

            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Streaming fetch error:', err);
                    container.innerHTML = `<div class="error-message">Error streaming response: ${escapeHtml(err.message)}</div>`;
                } else {
                    // If aborted, the finally block will handle cleanup.
                    // The partial message remains visible.
                }
            }
        }

        // Ensure Enter sends (unless Shift+Enter), and support Ctrl+Enter as send as well
        (function(){
            try {
                const ci = document.getElementById('chat-input');
                if (ci) {
                    ci.addEventListener('keydown', function(ev){
                        if (ev.key === 'Enter' && !ev.shiftKey) {
                            ev.preventDefault();
                            // If a response is in progress, Enter stops it; otherwise, it sends
                            if (window._currentAbortController) {
                                try { window._currentAbortController.abort(); } catch(e) {}
                            } else {
                                submitData();
                            }
                        } else if ((ev.key === 'Enter' && (ev.ctrlKey || ev.metaKey))) {
                            ev.preventDefault();
                            if (window._currentAbortController) {
                                try { window._currentAbortController.abort(); } catch(e) {}
                            } else {
                                submitData();
                            }
                        }
                    });
                }
            } catch(e){ console.warn(e); }
        })();

        // ------------------------------
        // UI helpers referenced by inline handlers
        // ------------------------------
        function toggleToolTray(e){
            e?.preventDefault();
            const panel = document.getElementById('tool-buttons');
            const btn = document.getElementById('toggle-tools-btn');
            if (!panel || !btn) return;
            const willOpen = panel.classList.contains('collapsed');
            panel.classList.toggle('collapsed');
            btn.classList.toggle('active');
            if (willOpen) {
                // close when clicking outside
                const onDocClick = (ev) => {
                    if (btn.contains(ev.target) || panel.contains(ev.target)) return;
                    panel.classList.add('collapsed');
                    btn.classList.remove('active');
                    document.removeEventListener('click', onDocClick, true);
                };
                // delay to avoid immediate closing by current click
                setTimeout(()=>document.addEventListener('click', onDocClick, true), 0);
            }
        }

        function toggleHistoryMode(){
            // For mobile: reuse the same sidebar overlay. Just toggle it.
            try {
                const topToggle = document.getElementById('history-drawer-toggle');
                const hdrBtn = document.getElementById('history-toggle-btn');
                if (topToggle) topToggle.click();
                if (hdrBtn) hdrBtn.classList.toggle('active');
            } catch(e){ console.warn('toggleHistoryMode error', e); }
        }

        function startNewConversation(){
            try {
                // create a fresh session id
                currentSessionId = 'sess-' + Date.now();
                try { localStorage.setItem('jaremis_session', currentSessionId); } catch(_) {}
                // reset UI messages to greeting
                chatMessages.innerHTML = '<div style="height:12px;"></div>'+
                  '<div class="chat-bubble bot-bubble">'+
                  '<strong>Chào bạn 👋 Mình là JAREMIS.</strong>'+
                  '<p style="margin-top:8px; color:var(--text-secondary-color);">Hãy nhập các dấu hiệu, hỏi chuyện, hoặc bật chế độ <strong>Diagnose</strong> để yêu cầu chẩn đoán y khoa.</p>'+
                  '</div>';
                chatMessages.scrollTop = chatMessages.scrollHeight;
                // clear input & previews
                chatInput.value = '';
                autoResize(chatInput);
                imagePreviewContainer.innerHTML = '';
                // close sidebar if open (mobile)
                const sidebarEl = document.getElementById('sidebar');
                const backdrop = document.getElementById('sidebar-backdrop');
                if (sidebarEl && sidebarEl.classList.contains('mobile-open')){
                    sidebarEl.classList.remove('mobile-open');
                    if (backdrop){ backdrop.classList.remove('show'); backdrop.style.display='none'; }
                    const drawerBtn = document.getElementById('history-drawer-toggle');
                    if (drawerBtn) drawerBtn.classList.remove('open');
                }
            } catch(e){ console.warn('startNewConversation error', e); }
        }
        // ------------------------------
        // Missing helpers: thinking animation, typewriter reply, error display
        // These were referenced but not defined previously; implement robust versions
        // ------------------------------
        function startThinking(bubble){
            if(!bubble) return;
            try{ clearInterval(bubble._thinkInterval); }catch(e){}
            bubble.dataset.katexRendered = '0';
            bubble.innerHTML = '';
            const wrapper = document.createElement('div');
            wrapper.style.display = 'flex';
            wrapper.style.flexDirection = 'column';
            wrapper.style.gap = '8px';

            const text = document.createElement('div');
            text.className = 'thinking-text';
            text.style.color = 'var(--text-secondary-color)';
            text.style.fontSize = '14px';
            text.textContent = 'đang suy nghĩ lâu hơn để giúp bạn hài lòng hơn';

            const dots = document.createElement('div');
            dots.className = 'thinking-dots';
            dots.style.color = 'var(--text-secondary-color)';
            dots.style.fontSize = '14px';

            wrapper.appendChild(text);
            wrapper.appendChild(dots);
            bubble.appendChild(wrapper);

            let dcount = 0;
            bubble._thinkInterval = setInterval(()=>{
                dcount = (dcount + 1) % 4;
                const n = dcount === 0 ? 1 : dcount; // at least one dot
                dots.textContent = '.'.repeat(n);
            }, 400);
            bubble._thinking = true;
            return bubble._thinkInterval;
        }

        function stopThinking(bubble){
            try{
                if(bubble && bubble._thinkInterval) clearInterval(bubble._thinkInterval);
            }catch(e){}
            if(bubble){ bubble._thinking = false; }
        }

        function showError(message, targetBubble){
            console.error('showError:', message);
            if (targetBubble && targetBubble.parentNode) {
                targetBubble.innerHTML = `<div style="color:var(--error-color); font-weight:600;">Lỗi: ${escapeHtml(String(message))}</div>`;
            } else {
                const b = document.createElement('div');
                b.className = 'chat-bubble bot-bubble';
                b.innerHTML = `<div style="color:var(--error-color); font-weight:600;">Lỗi: ${escapeHtml(String(message))}</div>`;
                chatMessages.appendChild(b);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }

        // Simple markdown-ish converter used as fallback when server doesn't provide HTML
        function convertMarkdown(raw){
            if(!raw) return '';
            const maybeHtml = /<[^>]+>/g.test(raw);
            if(maybeHtml) return raw;
            let s = escapeHtml(raw);
            s = s.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1<\/a>');
            s = s.split(/\n\n+/).map(p => `<p>${p.replace(/\n/g,'<br>')}</p>`).join('');
            return s;
        }

        // Typewriter / progressive reveal for bot replies. Works with HTML by appending node-by-node and typing text-nodes.
        async function renderBotReplyAnimated(targetBubble, html){
            if(!targetBubble) return;
            stopThinking(targetBubble);
            targetBubble.innerHTML = '';
            const container = document.createElement('div');
            container.className = 'bot-reply';
            targetBubble.appendChild(container);

            // Gemini-like: reveal line-by-line (rows), with soft fade/slide and natural pauses.
            let fastForward = false;
            const onFast = () => {
                fastForward = true;
                // Instantly render the rest of the content
                container.innerHTML = html;
                // Make sure all child elements are visible instantly
                Array.from(container.children).forEach(child => child.classList.add('gemini-visible'));
                // And render any math
                try {
                    if (window.jaremis && typeof window.jaremis.ensureRenderMath === 'function') {
                        window.jaremis.ensureRenderMath(targetBubble);
                    } else if (typeof window.renderMathIn === 'function') {
                        window.renderMathIn(targetBubble);
                    }
                } catch(_){}
            };
            targetBubble.addEventListener('click', onFast, { once: true });

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            const cfg = {
                lineBase: window.GEMINI_LINE_BASE_MS ?? 80,          // base delay per line
                perChar: window.GEMINI_LINE_PER_CHAR_MS ?? 1.1,       // extra ms per char for rhythm
                sentencePause: window.GEMINI_SENTENCE_PAUSE_MS ?? 150, // extra pause after sentence-ending punctuation
                blockGap: window.GEMINI_BLOCK_GAP_MS ?? 120            // pause between major blocks (e.g. paragraphs)
            };

            function endsSentence(text){
                return /[\.!?…]\s*$/.test(text || '');
            }

            // Use marked.js to parse the markdown into a token stream
            const tokens = marked.lexer(html);
            const renderer = new marked.Renderer();

            for (const token of tokens) {
                if (fastForward) break;

                // Create a temporary list containing only the current token for the parser
                const singleTokenList = [token];
                singleTokenList.links = tokens.links; // Important: parser needs the links object

                const htmlFragment = marked.parser(singleTokenList, { renderer });

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlFragment.trim();

                const element = tempDiv.firstChild;

                if (element && element.nodeType === Node.ELEMENT_NODE) {
                    container.appendChild(element);

                    // Wait a frame for the element to be in the DOM but invisible
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    if (fastForward) break;

                    // Add class to trigger the CSS animation
                    element.classList.add('gemini-visible');

                    // Calculate dynamic delay for the next element
                    const text = element.textContent || '';
                    let delay = cfg.lineBase + text.length * cfg.perChar;
                    if (endsSentence(text)) {
                        delay += cfg.sentencePause;
                    }

                    await sleep(delay);
                } else if (htmlFragment.trim()) {
                    // Handle plain text nodes if any
                    const textNode = document.createTextNode(htmlFragment);
                    container.appendChild(textNode);
                    await sleep(cfg.lineBase);
                }
            }

            // If fast-forward was triggered, it already rendered everything.
            // If not, we just need to ensure math is rendered.
            if (!fastForward) {
                try {
                    if (window.jaremis && typeof window.jaremis.ensureRenderMath === 'function') {
                        window.jaremis.ensureRenderMath(targetBubble);
                    } else if (typeof window.renderMathIn === 'function') {
                        window.renderMathIn(targetBubble);
                    }
                } catch(_){}
            }

            // Clean up listener
            try { targetBubble.removeEventListener('click', onFast, { once: true }); } catch(_) {}
        }
     </script>
     <script>
/* === 3D Tilt Effect Script ===
   Áp dụng cho: đăng nhập / đăng xuất / xóa lịch sử (auth-btn),
   nút Diagnose (#mode-btn), Jaremis Pro (#think-btn),
   đính kèm file (paperclip – nút action-btn đầu tiên trong #tool-buttons),
   ghi âm (#mic-btn).
   Muốn thêm send: thêm '#send-btn' vào SELECTORS.
*/
(function(){
  const SELECTORS = [
    '.auth-controls .auth-btn',        // đăng nhập / đăng ký / đăng xuất / xóa lịch sử
    '#mode-btn',                       // Diagnose toggle
    '#think-btn',                      // Jaremis Pro
    '#mic-btn',                        // Mic
    '#tool-buttons .action-btn:first-child', // Paperclip
    '.new-chat-btn',                   // "Cuộc trò chuyện mới"
    '#send-btn',                       // Gửi
    '.btn-primary',                    // Nút Đăng nhập / Đăng ký
    '.btn-ghost'                       // Nút Hủy
  ];
  const MAX_TILT = 14;
  const PERSPECTIVE = 800;
  function applyTilt(el){
    if(!el || el.dataset.tiltApplied) return;
    el.dataset.tiltApplied = '1';
    el.classList.add('tilt-3d');
    function move(e){
      const rect = el.getBoundingClientRect();
      const x = (e.clientX - rect.left)/rect.width;
      const y = (e.clientY - rect.top)/rect.height;
      const rotX = (0.5 - y) * (MAX_TILT * 2);
      const rotY = (x - 0.5) * (MAX_TILT * 2);
      el.style.setProperty('--mx', (x*100).toFixed(2)+'%');
      el.style.setProperty('--my', (y*100).toFixed(2)+'%');
      el.style.transform = `perspective(${PERSPECTIVE}px) rotateX(${rotX}deg) rotateY(${rotY}deg) translateZ(6px)`;
      el.style.setProperty('--glow-o','1');
    }
    function leave(){
      el.style.transform = `perspective(${PERSPECTIVE}px) rotateX(0deg) rotateY(0deg) translateZ(0)`;
      el.style.setProperty('--glow-o','0');
    }
    el.addEventListener('mousemove', move);
    el.addEventListener('mouseenter', move);
    el.addEventListener('mouseleave', leave);
    el.addEventListener('touchmove', (e)=>{
      const t = e.touches[0];
      move(t);
    }, {passive:true});
    el.addEventListener('touchend', leave);
  }
  function scan(){
    SELECTORS.forEach(sel=>{
      document.querySelectorAll(sel).forEach(applyTilt);
    });
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    scan();
    // Quan sát auth-controls vì nút được tạo động
    const auth = document.querySelector('.auth-controls');
    if(auth){
      new MutationObserver(scan).observe(auth,{childList:true,subtree:true});
    }
  });
})();
</script>
<script>
// ================= REALISTIC SNOW v2 (restored) =================
(function(){
  const canvas = document.getElementById('snow-canvas');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const CONFIG = {
    density: 0.11,
    globalSpeed: 1.0,
    windOscAmp: 0.55,
    windOscSpeed: 0.06,
    perParticleSway: 0.35,
    maxDrift: 0.35,
    fadeIn: true
  };
  const LAYERS = [
    { name:'far',  size:[0.6,1.4], speedY:[14,24], alpha:[0.15,0.35], blur:0,   countRatio:0.40 },
    { name:'mid',  size:[1.0,2.2], speedY:[22,38], alpha:[0.22,0.55], blur:0.5, countRatio:0.38 },
    { name:'near', size:[1.8,3.4], speedY:[34,58], alpha:[0.30,0.75], blur:0.9, countRatio:0.22 }
  ];
  let W=0,H=0, particles=[];
  let lastTime = performance.now();
  let windBase = 0;
  function rand(a,b){ return Math.random()*(b-a)+a; }
  function resize(){
    W = canvas.width  = canvas.offsetWidth  = canvas.parentElement.offsetWidth;
    H = canvas.height = canvas.offsetHeight = canvas.parentElement.offsetHeight;
    buildParticles();
  }
  window.addEventListener('resize', throttle(resize,250));
  resize();
  function totalCount(){ return Math.round((W*H/1000) * CONFIG.density); }
  function buildParticles(){
    particles.length = 0;
    const total = totalCount();
    LAYERS.forEach(layer=>{
      const need = Math.round(total * layer.countRatio);
      for(let i=0;i<need;i++){
        particles.push(makeParticle(layer, Math.random()*W, Math.random()*H));
      }
    });
  }
  function makeParticle(layer,x,y){
    const speedY = rand(layer.speedY[0], layer.speedY[1]) / 60 * CONFIG.globalSpeed;
    const r = rand(layer.size[0], layer.size[1]);
    return {
      layer,x,y,r,
      baseVy: speedY,
      alpha: rand(layer.alpha[0], layer.alpha[1]),
      swayOffset: Math.random()*Math.PI*2,
      swaySpeed: rand(0.4,1.1),
      driftSeed: Math.random()*1000,
      life:0,
      blur:layer.blur
    };
  }
  function update(dt){
    windBase += CONFIG.windOscSpeed * dt;
    const globalWind = Math.sin(windBase) * CONFIG.windOscAmp;
    for(let p of particles){
      p.life += dt;
      const sway = Math.sin(p.swayOffset + p.life * p.swaySpeed) * CONFIG.perParticleSway;
      const drift = (Math.sin((p.driftSeed + p.life*30)*0.015)+Math.sin((p.driftSeed + p.life*55)*0.011))*0.5*CONFIG.maxDrift;
      p.x += (globalWind + sway + drift) * (0.6 + (p.r*0.12));
      p.y += p.baseVy * dt * 60;
      if(p.x > W+8) p.x = -8;
      else if(p.x < -8) p.x = W+8;
      if(p.y > H+10){
        p.x = Math.random()*W;
        p.y = rand(-40,-10);
        p.life = 0;
        p.baseVy = rand(p.layer.speedY[0], p.layer.speedY[1]) / 60 * CONFIG.globalSpeed;
        p.r = rand(p.layer.size[0], p.layer.size[1]);
        p.alpha = rand(p.layer.alpha[0], p.layer.alpha[1]);
      }
    }
  }
  function draw(){
    ctx.clearRect(0,0,W,H);
    for(let layer of LAYERS){
      ctx.save();
      for(let p of particles){
        if(p.layer !== layer) continue;
        const a = CONFIG.fadeIn ? Math.min(p.alpha, p.alpha*(p.life*0.6)) : p.alpha;
        ctx.globalAlpha = a;
        if(p.blur>0){
          ctx.shadowBlur = p.blur*8;
          ctx.shadowColor = 'rgba(255,255,255,'+a+')';
        } else ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.fillStyle = '#fff';
        ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }
  }
  function loop(now){
    const dt = Math.min(0.07, (now - lastTime)/1000);
    lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  function throttle(fn, ms){
    let t=0;
    return function(...args){
      if(performance.now()-t>ms){ t=performance.now(); fn.apply(this,args); }
    };
  }
})();
</script>
<script>
// ==== FIND MODAL (Word-like) ====
let findMatches = [];
let currentFindIndex = -1;
let lastFindQuery = '';
let findObserver = null;

function openFindModal(){
  const b = document.getElementById('find-backdrop');
  if(!b) return;
  b.style.display='flex';
  const inp = document.getElementById('find-query');
  setTimeout(()=>inp.focus(),30);
  if(lastFindQuery){ inp.value = lastFindQuery; performFind(lastFindQuery); }
}
function closeFindModal(){
  const b = document.getElementById('find-backdrop');
  if(b) b.style.display='none';
  clearFindHighlights();
}
document.addEventListener('keydown', e=>{
  if(e.key==='Escape'){
    const b=document.getElementById('find-backdrop');
    if(b && b.style.display!=='none'){ closeFindModal(); }
  }
});

function performFind(q){
  lastFindQuery = q;
  clearFindHighlights(true);
  if(!q){
    updateFindCount();
    return;
  }
  const caseSensitive = document.getElementById('find-case')?.checked;
  let re;
  try { re = new RegExp(escapeRegExp(q), caseSensitive?'g':'gi'); } catch(_){ return; }
  const container = document.getElementById('chat-messages');
  if(!container) return;

  const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, {
    acceptNode: n=>{
      if(!n.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
      if(n.parentElement && n.parentElement.classList.contains('find-highlight')) return NodeFilter.FILTER_REJECT;
      return NodeFilter.FILTER_ACCEPT;
    }
  });
  const nodes=[];
  while(walker.nextNode()) nodes.push(walker.currentNode);

  nodes.forEach(node=>{
    const txt = node.nodeValue;
    let m,last=0,frag=document.createDocumentFragment(),found=false;
    re.lastIndex=0;
    while((m = re.exec(txt))!==null){
      found=true;
      const pre = txt.slice(last,m.index);
      if(pre) frag.appendChild(document.createTextNode(pre));
      const span = document.createElement('span');
      span.className='find-highlight';
      span.textContent=m[0];
      frag.appendChild(span);
      findMatches.push(span);
      last = m.index + m[0].length;
      if(m[0].length===0) re.lastIndex++;
    }
    if(found){
      const rest = txt.slice(last);
      if(rest) frag.appendChild(document.createTextNode(rest));
      node.parentNode.replaceChild(frag,node);
    }
  });

  currentFindIndex = findMatches.length?0:-1;
  activateCurrentMatch();
  updateFindCount();

  if(findObserver) findObserver.disconnect();
  if(q){
    findObserver = new MutationObserver(()=>{
      const qq = lastFindQuery;
      if(qq) performFind(qq);
    });
    findObserver.observe(container,{childList:true,subtree:true});
  }
}

function findNext(){
  if(!findMatches.length){
    performFind(document.getElementById('find-query').value.trim());
    return;
  }
  currentFindIndex = (currentFindIndex+1) % findMatches.length;
  activateCurrentMatch();
  updateFindCount();
}
function findPrev(){
  if(!findMatches.length){
    performFind(document.getElementById('find-query').value.trim());
    return;
  }
  currentFindIndex = (currentFindIndex-1 + findMatches.length) % findMatches.length;
  activateCurrentMatch();
  updateFindCount();
}

function activateCurrentMatch(){
  findMatches.forEach(s=>s.classList.remove('active'));
  if(currentFindIndex>=0 && findMatches[currentFindIndex]){
    const el = findMatches[currentFindIndex];
    el.classList.add('active');
    const container = document.getElementById('chat-messages');
    const rect = el.getBoundingClientRect();
    const cRect = container.getBoundingClientRect();
    const scrollTo = rect.top - cRect.top + container.scrollTop - (container.clientHeight/2) + rect.height/2;
    container.scrollTo({ top: scrollTo, behavior:'smooth' });
  }
}

function updateFindCount(){
  const el = document.getElementById('find-count');
  if(!el) return;
  if(!findMatches.length) el.textContent='0 / 0';
  else el.textContent=(currentFindIndex+1)+' / '+findMatches.length;
}

function clearFindHighlights(keepObs){
  if(findObserver && !keepObs){ findObserver.disconnect(); findObserver=null; }
  if(!findMatches.length) return;
  findMatches.forEach(span=>{
    if(span.parentNode){
      span.parentNode.replaceChild(document.createTextNode(span.textContent), span);
    }
  });
  findMatches=[];
  currentFindIndex=-1;
  updateFindCount();
}

function escapeRegExp(str){ return str.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }

document.addEventListener('DOMContentLoaded', ()=>{
  const q=document.getElementById('find-query');
  if(q){
    q.addEventListener('input', e=>performFind(e.target.value.trim()));
    q.addEventListener('keydown', e=>{
      if(e.key==='Enter'){
        e.preventDefault();
        if(e.shiftKey) findPrev(); else findNext();
      }
    });
  }
  const c=document.getElementById('find-case');
  if(c){ c.addEventListener('change', ()=>performFind(q.value.trim())); }
});
</script>

<!-- KaTeX helper & auto-render (Doctor-style) -->
<script>
(function(){
  if (window._jaremis_shortcuts_installed) return; window._jaremis_shortcuts_installed = true;

  // Safe helper to click an element by id
  function tryClick(id){ try{ const el = document.getElementById(id); if(el){ el.click(); return true; } }catch(e){} return false; }

  // Provide lightweight global stubs (will defer to real implementations when available)
  window.jaremis = window.jaremis || {};
  window.jaremis.ensureRenderMath = function(el){ if (window.renderMathIn) return window.renderMathIn(el); /* no-op until katex loader runs */ };
  // Keep existing wrapResultMath/addResultBoxStyles if present; otherwise noop
  if (!window.wrapResultMath) window.wrapResultMath = function(b){ /* will be replaced by real implementation if defined later */ };
  if (!window.addResultBoxStyles) window.addResultBoxStyles = function(){ };

  // Keyboard shortcuts mapping (use Ctrl+letter / Ctrl+Shift+letter). Avoid overriding basic input behavior.
  document.addEventListener('keydown', function(e){
    const tgt = e.target || {};
    const tag = (tgt.tagName || '').toUpperCase();
    const isEditable = tag === 'INPUT' || tag === 'TEXTAREA' || tgt.isContentEditable;

    // Ctrl+Enter -> send (works even when typing)
    if (e.ctrlKey && !e.shiftKey && e.key === 'Enter') {
      e.preventDefault(); tryClick('send-btn'); return;
    }

    // If typing in a text field, do not hijack other shortcuts (except send)
    if (isEditable) return;

    // Map single Ctrl+letter and Ctrl+Shift+letter combinations
    if (e.ctrlKey && !e.altKey) {
      const k = (e.key || '').toLowerCase();
      const shift = e.shiftKey;
      // Mic: Ctrl+M
      if (!shift && k === 'm') { e.preventDefault(); tryClick('mic-btn'); flashNotice && flashNotice('Mic toggled (Ctrl+M)'); return; }
      // Attach: Ctrl+Shift+U
      if (shift && k === 'u') { e.preventDefault(); tryClick('attach-btn') || document.getElementById('images')?.click(); flashNotice && flashNotice('Attach file (Ctrl+Shift+U)'); return; }
      // Diagnose: Ctrl+Shift+K
      if (shift && k === 'k') { e.preventDefault(); tryClick('mode-btn'); flashNotice && flashNotice('Toggle Diagnose (Ctrl+Shift+K)'); return; }
      // Model switch: Ctrl+Shift+Y
      if (shift && k === 'y') { e.preventDefault(); tryClick('think-btn'); flashNotice && flashNotice('Switch model (Ctrl+Shift+Y)'); return; }
      // New chat: Ctrl+Shift+X
      if (shift && k === 'x') { e.preventDefault(); startNewConversation && startNewConversation(); flashNotice && flashNotice('New chat (Ctrl+Shift+X)'); return; }
      // Open history/find: Ctrl+Shift+F
      if (shift && k === 'f') { e.preventDefault(); openFindModal && openFindModal(); flashNotice && flashNotice('Find (Ctrl+Shift+F)'); return; }
    }
  }, true);

  // Ensure chatInput Ctrl+Enter works even if focus is inside textarea
  try { const ci = document.getElementById('chat-input'); const sb = document.getElementById('send-btn');
    if (ci && sb) {
      ci.addEventListener('keydown', function(ev){ if (ev.ctrlKey && ev.key === 'Enter') { ev.preventDefault(); sb.click(); } });
    }
  } catch(e){}

})();
</script>
<!-- KaTeX helper & auto-render (Doctor-style) -->
<script>
// Define helper like Doctor's implementation and an unobtrusive observer
if (!window._jaremis_katex_setup) {
  window._jaremis_katex_setup = true;

  // renderMathIn wrapper (safe: no throw, ignores code/pre)
  function renderMathIn(el){
    if (!el || !window.renderMathInElement) return;
    try{
      window.renderMathInElement(el, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$',  right: '$',  display: false},
          {left: '\\[', right: '\\]', display: true},
          {left: '\\(', right: '\\)', display: false}
        ],
        throwOnError: false,
        ignoredTags: ['script','noscript','style','textarea','pre','code'],
        ignoredClasses: ['no-math','katex']
      });
    }catch(err){
      // don't interfere with app; just warn
      console.warn('renderMathIn error', err);
    }
  }

  window.renderMathIn = renderMathIn;

  // Normalize LaTeX delimiters inside text nodes of an element.
  function normalizeLatexInElement(el){
    if(!el) return;
    try{
      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
      const nodes = [];
      while(walker.nextNode()) nodes.push(walker.currentNode);
      nodes.forEach(n => {
        let s = n.nodeValue;
        if(!s || (!s.includes('$') && !s.includes('\\(') && !s.includes('\\['))) return;
        // Collapse repeated dollar signs (e.g. $$$ -> $$)
        s = s.replace(/\${3,}/g, '$$');
        // Convert display $$...$$ to \[ ... \]
        s = s.replace(/\$\$(.*?)\$\$/gs, '\\[$1\\]');
        // Convert simple inline $...$ to \\( ... \\)
        // Avoid replacing when $ is adjacent to whitespace at boundaries
        s = s.replace(/\$(\S[\s\S]*?\S)\$/gs, '\\\($1\\\)');
        // Trim accidental spaces inside delimiters
        s = s.replace(/\\\(\s+/g,'\\\\(').replace(/\s+\\\)/g,'\\\\)');
        n.nodeValue = s;
      });
    }catch(err){ console.warn('normalizeLatexInElement error', err); }
  }

  function cleanupStrayDollarSigns(el){
    if(!el) return;
    try{
      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
      const nodes = [];
      while(walker.nextNode()) nodes.push(walker.currentNode);
      for(const n of nodes){
        // skip text nodes that are inside a KaTeX-rendered element
        if(n.parentElement && n.parentElement.closest && n.parentElement.closest('.katex')) continue;
        let s = n.nodeValue;
        if(!s || !s.includes('$')) continue;
        // Remove unescaped single or double dollar signs left over (keep escaped \$)
        // Use lookbehind to avoid removing \$
        try{
          s = s.replace(/(?<!\\)\${1,2}/g, '');
        }catch(e){
          // fallback for older engines: remove all $ then restore escaped sequences
          s = s.replace(/\\\$/g, '__ESC_DOLLAR__').replace(/\$/g,'').replace(/__ESC_DOLLAR__/g,'\\$');
        }
        n.nodeValue = s;
      }
    }catch(err){ console.warn('cleanupStrayDollarSigns error', err); }
  }

  function renderBubbleIfNeeded(bubble){
    if (!bubble || bubble.dataset.katexRendered) return;
    if (!bubble.classList || !bubble.classList.contains('chat-bubble')) return;
    // Normalize delimiters first to avoid stray $ and inconsistent markers
    normalizeLatexInElement(bubble);
    renderMathIn(bubble);
    // Remove any leftover $ or $$ in plain text nodes outside KaTeX elements
    cleanupStrayDollarSigns(bubble);
    bubble.dataset.katexRendered = '1';
  }

  // Auto-render existing chat bubbles and newly added ones.
  document.addEventListener('DOMContentLoaded', ()=>{
    const container = document.getElementById('chat-messages');
    if (!container) return;
    // Render existing bubbles
    container.querySelectorAll('.chat-bubble').forEach(renderBubbleIfNeeded);
    // Observe added nodes
    const mo = new MutationObserver(muts=>{
      for (const m of muts){
        for (const n of m.addedNodes){
          if (n.nodeType !== 1) continue;
          if (n.classList && n.classList.contains('chat-bubble')) renderBubbleIfNeeded(n);
          else if (n.querySelectorAll) n.querySelectorAll('.chat-bubble').forEach(renderBubbleIfNeeded);
        }
      }
    });
    mo.observe(container, { childList: true, subtree: true });
  });
}
</script>
</body>
</html>